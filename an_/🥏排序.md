<div style="float: left; width: 64%; padding: 1%;">

好的，同学们，第八章“排序”是数据结构课程的**压轴大戏**，也是考研算法部分的绝对核心。这一章的特点是算法多、概念杂，但考点非常集中。**快速排序、堆排序、归并排序**是三大重点，要求大家不仅要理解思想，更要能**上手模拟整个排序过程**。各种算法的**时间/空间复杂度**和**稳定性**的对比，是选择题的必考内容。

下面我们逐一击破，用最精炼的方式掌握所有排序算法的精髓。

---

### **第8章 排序**

#### **8.1 排序的基本概念**

* **重要考点**
    * **稳定性**：排序算法的核心评价指标之一。
    * **内部排序** vs **外部排序**。

* **形象记忆法（学生排队）**
    * **排序**：让一群高矮不一的学生按身高排成一队。
    * **稳定性**：队伍里有两个叫“小明”的同学，他们身高一样。
        * **稳定排序**：排完队后，原来排在前面的那个小明，依然在新队伍的前面。
        * **不稳定排序**：排完队后，两个小明的相对位置可能发生了变化。
    * **内部排序**：所有学生都在一个**操场（内存）**上排队。
    * **外部排序**：学生太多，操场站不下，大部分人在**教室（外存）**里等着，分批叫到操场上排，排好后再送回教室。

---

#### **8.2 插入排序**

* **核心思想**：将一个记录插入到**已经排好序**的有序表中，从而得到一个新的、记录数增1的有序表。

* **形象记忆法（打扑克）**
    * **插入排序**：就像你玩斗地主时整理手牌。每次摸一张新牌，你都会找到它在手里合适的位置，然后把它插进去。

##### **8.2.1 直接插入排序**
* **过程**：从第二个数开始，依次向前比较，找到自己的位置并插入。
* **特点**：
    * **时间**：$O(n^2)$。但如果序列**基本有序**，效率很高，接近 $O(n)$。
    * **空间**：$O(1)$。
    * **稳定性**：**稳定**。

##### **8.2.2 折半插入排序**
* **过程**：用**折半查找**来确定新元素插入的位置，然后统一移动元素。
* **特点**：
    * **优化**：减少了“比较”次数，但**“移动”次数没变**。
    * **时间**：$O(n^2)$，整体性能提升不明显。
    * **稳定性**：**稳定**。

##### **8.2.3 希尔排序**
* **过程**：分组的插入排序。先按一个大步长 `dk` 分组，对每组进行插入排序；然后缩小步长，再分组排序...直到步长为1。
* **特点**：
    * **优化**：分组排序让元素能一次性地“大步”移动，比直接插入快得多。
    * **时间**：介于 $O(n^2)$ 和 $O(n\log n)$ 之间，约为 $O(n^{1.3})$。
    * **稳定性**：**不稳定**。（因为分组跳跃式移动，可能打乱相同元素的顺序）

---

#### **8.3 交换排序**

* **核心思想**：根据序列中两个记录键值的比较结果，来对换这两个记录在序列中的位置。

##### **8.3.1 冒泡排序**
* **过程**：两两相邻比较，逆序则交换。每趟排序都像一个“气泡”把最大（或最小）的元素“冒”到最终位置。
* **特点**：
    * **时间**：$O(n^2)$。
    * **空间**：$O(1)$。
    * **稳定性**：**稳定**。（因为只交换相邻元素）

##### **8.3.2 快速排序（本章第一重点）**
* **核心思想**：**分治法**。
* **形象记忆法（司令点兵）**
    * **快排**：司令（`Partition`函数）在队伍里随便找一个人（`pivot` 基准），让他出列。然后对其他人下命令：“比他矮的站左边，比他高的站右边！”。这样一次操作，基准就站到了他最终应该在的位置。然后司令任命两个“副司令”，对左右两边的新队伍重复这个过程。

* **解题模板（模拟一趟划分过程）**
    **题目**：对序列 `[49, 38, 65, 97, 76, 13, 27]` 进行一趟快排。
    **模板（挖坑法）：**
    1.  **选基准**：选第一个数 `49` 为基准 `pivot`，此时 `A[0]` 形成一个“坑”。设指针 `i=0, j=6`。
    2.  **`j` 从右往左找小的**：`j` 移动，找到第一个比 `49` 小的数 `27`。将 `27` 填入 `A[i]` 的坑，`A[j]` 形成新坑。序列：`[27, 38, 65, 97, 76, 13, 27]` -> `[27, 38, 65, 97, 76, 13, 坑]`，`i=0, j=6`。
    3.  **`i` 从左往右找大的**：`i` 移动，找到第一个比 `49` 大的数 `65`。将 `65` 填入 `A[j]` 的坑，`A[i]` 形成新坑。序列：`[27, 38, 坑, 97, 76, 13, 65]`，`i=2, j=6`。
    4.  **重复**：`j` 左移找到 `13` -> 填坑 -> `[27, 38, 13, 97, 76, 坑, 65]`；`i` 右移找到 `97` -> 填坑 -> `[27, 38, 13, 坑, 76, 97, 65]`。
    5.  **相遇**：当 `i` 和 `j` 相遇时，将基准 `49` 填入最后的坑。
    6.  **结果**：`[27, 38, 13, 49, 76, 97, 65]`。`49` 已归位，左边都比它小，右边都比它大。
* **特点**：
    * **时间**：平均 $O(n\log n)$，最坏 $O(n^2)$（当序列基本有序时）。
    * **空间**：递归深度，平均 $O(\log n)$，最坏 $O(n)$。
    * **稳定性**：**不稳定**。

---

#### **8.4 选择排序**

* **核心思想**：每趟在待排序元素中选取关键字最小（或最大）的元素，加入到有序子序列。

##### **8.4.1 简单选择排序**
* **过程**：第一趟，从所有数中找到最小的，和第一个位置交换。第二趟，从剩下的数中找到最小的，和第二个位置交换...
* **特点**：
    * **时间**：$O(n^2)$，性能与初始序列无关。
    * **空间**：$O(1)$。
    * **稳定性**：**不稳定**。（例如 `[5, 8, 5, 2]`，第一趟会把第一个`5`和`2`交换）

##### **8.4.2 堆排序（本章第二重点）**
* **核心思想**：利用**完全二叉树**（堆）的特性进行排序。
* **形象记忆法（擂台赛选武林盟主）**
    * **堆排序**：所有武林高手（待排序数据）参加比武。
    1.  **建堆（海选赛）**：先把所有人排成一个“大根堆”（一棵完全二叉树，要求每个爹都比儿子强）。此时，掌门（根结点）就是武功最高的。
    2.  **排序（淘汰赛）**：
        * **选出冠军**：掌门（堆顶最大元素）当选本届武林盟主，让他去队伍**最后面**的荣誉席就坐。
        * **替补上位**：从队伍**末尾**随便找个小兵（最后一个元素）来当临时掌门。
        * **内部选拔**：这个小兵武功不行，从他的左右护法开始，层层往下比，把他“筛选”下去，让有实力的人重新当上掌门（**调整堆**）。
        * **重复**：不断选出新掌门（当前最大值），送到荣誉席（有序区的末尾）。

* **解题模板（建堆与调整）**
    * **建堆**：从最后一个**非叶子结点**（`n/2`）开始，从后往前，依次对每个结点执行“向下调整”操作。
    * **调整**：将根结点与其**较大的孩子**比较，若根小则交换，并继续向下调整，直到满足大根堆性质。
* **特点**：
    * **时间**：$O(n\log n)$，不受初始序列影响。
    * **空间**：$O(1)$。
    * **稳定性**：**不稳定**。

---

#### **8.5 归并排序、基数排序**

##### **8.5.1 归并排序（本章第三重点）**
* **核心思想**：**分治法**。
* **形象记忆法（先分后合）**
    * **归并排序**：老师要给一大摞卷子排序。
    1.  **分 (Divide)**：老师先把卷子**一分为二**，交给两个助教。助教也把各自的卷子一分为二...直到每个人手里只剩一张卷子（天然有序）。
    2.  **治/合 (Conquer/Merge)**：每个人把自己手里的有序卷子（可能不止一张）递给上一级，上一级助教负责把收上来的**两摞有序的卷子合并成一摞更大的有序卷子**。最后汇总到老师那里，整摞卷子就有序了。

* **特点**：
    * **时间**：$O(n\log n)$，非常稳定。
    * **空间**：$O(n)$，需要一个同样大小的辅助数组。
    * **稳定性**：**稳定**。

##### **8.5.2 基数排序**
* **核心思想**：不比较关键字大小，而是按关键字的**每一位**进行“分配”和“收集”。
* **形象记忆法（发扑克牌）**
    * **基数排序**：给一堆数字（比如三位数）排序。
    1.  准备10个桶，编号0-9。
    2.  **第一趟**：按**个位数**把所有数字扔进对应的桶里。然后按0-9号桶的顺序把数字**收集**起来。
    3.  **第二趟**：按**十位数**把新序列的数字扔进桶里，再收集。
    4.  **第三趟**：按**百位数**扔，再收集。
    5.  结束后，序列完全有序。
* **特点**：
    * **时间**：$O(d(n+r))$，其中 `d`是位数，`r`是基数（如10）。当 `d` 很小时，接近 $O(n)$。
    * **空间**：$O(r)$，需要桶的空间。
    * **稳定性**：**稳定**。

---

#### **8.6 各种内部排序算法的比较**

这是选择题的“题库”，必须滚瓜烂熟。

| 排序算法 | 平均时间 | 最坏时间 | 空间 | 稳定性 | 备注 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **插入排序** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | **稳定** | 序列基本有序时最快 |
| **希尔排序** | $O(n^{1.3})$ | $O(n^2)$ | $O(1)$ | **不稳定** | 插入排序的改进版 |
| **冒泡排序** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | **稳定** | 思想简单，基本不用 |
| **快速排序** | $O(n\log n)$ | $O(n^2)$ | $O(\log n)$ | **不稳定** | 平均性能最优 |
| **选择排序** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | **不稳定** | 移动次数最少 |
| **堆排序** | $O(n\log n)$ | $O(n\log n)$ | $O(1)$ | **不稳定** | 性能稳定，无需额外空间 |
| **归并排序** | $O(n\log n)$ | $O(n\log n)$ | $O(n)$ | **稳定** | 性能稳定，空间换时间 |
| **基数排序** | $O(d(n+r))$| $O(d(n+r))$| $O(r)$ | **稳定** | 不基于比较，适用整数 |

---

#### **8.7 外部排序**
* **核心思想**：**分块排序 + 多路归并**。
* **形象记忆**：见 8.1 节的外部排序定义。
* **重要考点**：
    * 外部排序的I/O次数是主要矛盾。
    * **减少归并趟数**的两种方法：
        1.  **增大归并路数 `k`** (用**败者树**优化内部比较)。
        2.  **减少初始归并段个数 `r`** (用**置换-选择排序**生成更长的初始归并段)。
    * **最佳归并树**：类似哈夫曼树，用于规划长度不等的归并段的合并顺序，使总I/O最少。
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
