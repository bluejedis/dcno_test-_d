<div style="float: left; width: 64%; padding: 1%;">

好的，同学们，我们进入第五章——树与二叉树。这是数据结构考研的**绝对核心**，是整个课程的“心脏”，分值高、考点多、应用广。无论是选择题还是算法大题，每年必考。这一章必须拿下，而且要学得非常扎实。

请跟上我的节奏，我们用最直观、最易记的方式，把这块硬骨头啃下来。

-----

### **第5章 树与二叉树**

#### **5.1 树的基本概念**

##### **5.1.1 & 5.1.2 树的定义与基本术语**

  * **重要考点**

      * 树的**递归定义**和**非线性**特性。
      * 各种术语的理解：结点、度、层次、深度、高度、森林等。
      * 树中**结点数**和**边数**的关系：`边数 = 结点数 - 1`。

  * **形象记忆法（公司组织架构图）**

      * **树**：就是一张公司的组织架构图。
      * **根结点**：公司的 **CEO**，没有上级。
      * **孩子结点**：你的**直接下属**。
      * **双亲结点**：你的**直接上级**。
      * **兄弟结点**：和你**平级**且**上级相同**的同事。
      * **叶子结点**：没有下属的**基层员工**。
      * **结点的度**：你管了**几个直接下属**。
      * **树的度**：整个公司里，管人最多的那位经理管了多少人。
      * **层次**：从CEO（第1层）开始往下数，你在第几层。
      * **深度**：同层次。
      * **高度**：从你开始往下数，你这个部门（子树）最多有多少层级。
      * **森林**：多个**独立的公司**放在一起。

##### **5.1.3 树的性质**

这部分是选择题的计算考点，必须记住公式。

  * **重要考点**

      * 结点数与度的关系：`结点总数 n = n0 + n1 + n2 + ...`
      * `结点总数 n = 总分支数(总度数) + 1`

  * **计算题解题模板**

      * **题目类型**：已知树的度为 `m`，以及某些度的结点个数，求叶子结点 `n0` 的个数。
      * **模板公式**：
        1.  写出结点总数方程：`n = n0 + n1 + n2 + ... + nm`
        2.  写出边数（总度数）方程：`n - 1 = 1*n1 + 2*n2 + ... + m*nm`
        3.  联立两个方程求解未知数。
      * **例题**：某树有 `n1` 个度为1的结点，`n2` 个度为2的结点，...，`nm` 个度为m的结点，求叶子结点 `n0` 的数量。
      * **解**：`n0 = n2 + 2*n3 + 3*n4 + ... + (m-1)*nm + 1` (由 `n = Σni` 和 `n-1 = Σi*ni` 推导)

-----

#### **5.2 二叉树的概念**

二叉树是树中最重要的一种形态，是所有考点的重中之重。

##### **5.2.1 二叉树定义及主要特性**

  * **重要考点**

      * 二叉树与度为2的树的**区别**：二叉树是**有序树**（左右子树不能交换），且可以为空。
      * **满二叉树** vs **完全二叉树**。
      * 二叉树的**性质**，尤其是性质1：`n0 = n2 + 1`。

  * **形象记忆法**

      * **二叉树**：一个严格执行“计划生育”的家族，每个家庭（结点）**最多只能生两个孩子**，而且要明确是“老大”（左孩子）还是“老二”（右孩子）。
      * **满二叉树**：一个“**完美**”的家族，每一代人都生满了两个孩子，直到最后一代全是没孩子的年轻人。形状是一个完美的等腰三角形。
      * **完全二叉树**：一个“**基本完美**”的家族。它从上到下、从左到右的编号，能和满二叉树的前 `n` 个家庭一一对应。
          * **特点**：除了最下面一层，上面都是满的；最下面一层，所有孩子都**靠左排列**。可以有缺口，但只能缺在**右边**。

  * **计算题解题模板（结点关系）**

      * **适用对象**：**完全二叉树**（或满二叉树）。
      * **模板** (设结点编号为 `i`，编号从1开始):
          * **找双亲**：`floor(i / 2)` ( `i>1` )
          * **找左孩子**：`2 * i` ( `2i <= n` )
          * **找右孩子**：`2 * i + 1` ( `2i+1 <= n` )
          * **判断叶子**：`i > floor(n / 2)`
          * **求树高**：`floor(log2(n)) + 1`

##### **5.2.2 二叉树的存储结构**

  * **重要考点**
      * **顺序存储**：只适用于**完全二叉树**，否则浪费巨大空间。
      * **链式存储（二叉链表）**：最常用的存储方式。
      * `n` 个结点的二叉链表，有 `n+1` 个空指针域。

-----

#### **5.3 二叉树的遍历和线索二叉树**

遍历是二叉树操作的基础，是算法大题的绝对高频考点。

##### **5.3.1 二叉树的遍历**

  * **重要考点**

      * **先序、中序、后序**遍历的递归思想和序列特点。
      * **层次遍历**需要使用**队列**。
      * 由两种遍历序列**唯一确定一棵二叉树**（必须包含中序）。

  * **形象记忆法（一家三口逛公园）**

      * 把每个子树看成一个**家庭**（**根**-父亲，**左**-大儿子，**右**-小儿子）。
      * **先序遍历 (NLR - 父亲优先)**：父亲先玩，然后带大儿子去玩，最后带小儿子去玩。
          * **序列特点**：第一个元素永远是**总根**。
      * **中序遍历 (LNR - 孩子优先，父亲居中)**：先让大儿子玩，然后父亲自己玩，最后让小儿子玩。
          * **序列特点**：总根在序列**中间**，左边是左子树，右边是右子树。
      * **后序遍历 (LRN - 孩子优先，父亲殿后)**：先让大儿子玩，再让小儿子玩，父亲最后收拾残局。
          * **序列特点**：最后一个元素永远是**总根**。

  * **代码题解题模板**

      * **递归遍历模板**：
        ```c
        void Traversal(BiTree T) {
            if (T != NULL) {
                // visit(T);  // <-- 先序位置 (N)
                Traversal(T->lchild);
                // visit(T);  // <-- 中序位置 (LNR)
                Traversal(T->rchild);
                // visit(T);  // <-- 后序位置 (LRN)
            }
        }
        ```
      * **由遍历序列构造二叉树模板**
        1.  **先序 + 中序**：
              * 在**先序**序列中找到**根**（第一个元素）。
              * 在**中序**序列中找到该**根**，其左边为左子树，右边为右子树。
              * 递归处理左右子树。
        2.  **后序 + 中序**：
              * 在**后序**序列中找到**根**（最后一个元素）。
              * 在**中序**序列中找到该**根**，其左边为左子树，右边为右子树。
              * 递归处理左右子树。

##### **5.3.2 线索二叉树**

  * **重要考点**
      * **目的**：利用 `n+1` 个空指针域，存放结点在特定遍历次序下的**前驱**和**后继**信息，方便非递归遍历。
      * **线索化**：在遍历过程中，用一个 `pre` 指针记录上一个访问的结点，从而建立线索。

-----

#### **5.4 树、森林**

##### **5.4.1 & 5.4.2 树、森林与二叉树的转换**

这是本节的绝对核心，是理解树和二叉树关系的关键。

  * **重要考点**

      * **转换规则**：“左孩子，右兄弟”。
      * 树/森林的遍历与转换后二叉树遍历的对应关系。

  * **形象记忆法（家族重组）**

      * **树 -\> 二叉树**：
        1.  **认亲**：所有亲兄弟**手拉手**连成一条线。
        2.  **断舍离**：每个父亲只认**大儿子**（第一个孩子），与其他儿子断绝“父子关系线”。
        3.  **重组家庭**：形成的新关系是：**左指针**指向自己的**大儿子**，**右指针**指向自己的**大弟弟**（下一个兄弟）。
      * **森林 -\> 二叉树**：
        1.  先把森林里**每棵树**都按上述方法变成二叉树。
        2.  把所有树的**树根**（CEO们）看作是**亲兄弟**，让他们手拉手。
        3.  最终形成一棵**巨大的二叉树**。

  * **遍历对应关系（必考）**

      * 树的**先根**遍历 `==` 对应二叉树的**先序**遍历。
      * 树的**后根**遍历 `==` 对应二叉树的**中序**遍历。
      * 森林的**先序**遍历 `==` 对应二叉树的**先序**遍历。
      * 森林的**中序**遍历 `==` 对应二叉树的**中序**遍历。

-----

#### **5.5 树与二叉树的应用**

##### **5.5.1 哈夫曼树和哈夫曼编码**

  * **重要考点**

      * **哈夫曼树**：带权路径长度(WPL)最短的二叉树，也叫最优二叉树。
      * **构造方法**：贪心算法。每次选权值最小的两个结点合并。
      * **特点**：权值越大的叶子离根越近；只有度为0和2的结点。
      * **哈夫曼编码**：一种前缀编码，任何一个编码都不是另一个编码的前缀。

  * **解题模板（构造哈夫曼树）**

    1.  **初始化**：将所有带权值的结点看作一个森林。
    2.  **循环合并**：
          * 在森林中选出**权值最小**的两棵树。
          * 创建一个新结点作为它们的**父结点**，新结点的权值为**二者之和**。
          * 从森林中删除这两棵树，并将新树加入森林。
    3.  **结束**：直到森林中只剩一棵树，即为哈夫曼树。

##### **5.5.2 并查集**

  * **重要考点**

      * **用途**：处理不相交集合的**合并**与**查询**问题。
      * **核心操作**：`Find` (查找代表元) 和 `Union` (合并集合)。
      * **存储结构**：双亲表示法（数组）。
      * **优化**：路径压缩、按秩/大小合并。

  * **形象记忆法（江湖门派）**

      * **并查集**：管理江湖中的各个门派。
      * **元素**：江湖中的每一个人。
      * **集合**：每个门派。
      * **代表元（根）**：每个门派的**掌门人**。
      * **`Find(x)`**：查找 `x` 这个人属于哪个门派（即找到他的掌门人）。
      * **`Union(x, y)`**：两个门派合并（比如，A门派并入B门派）。
      * **路径压缩（优化）**：小弟 `x` 找到掌门人后，下次为了快，直接拜掌门人为师父。所有路径上的小弟都这样做。
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
