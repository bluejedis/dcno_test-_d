<div style="float: left; width: 64%; padding: 1%;">

好的，同学们，第四章“串”在考纲里要求非常明确，就是**模式匹配**。其中，**KMP算法**是绝对的重中之重。这一章要么不考，一旦考到算法题，很可能就是围绕KMP展开。所以，大家要把目标锁定在**手工求next数组**和理解KMP原理上。

---

### **第4章 串**

#### ***4.1 串的定义和实现**

这部分内容作为了解即可，是理解模式匹配的基础。

* **重要考点**
    * 串是一种特殊的线性表，特殊之处在于其数据元素只能是**字符**，其操作通常以**子串**为单位。
    * **空串** `""` 和 **空格串** `" "` 是两个完全不同的概念。

* **形象记忆法（文字处理）**
    * **线性表** 像一个**购物清单**，我们关心的是单个商品（元素）的增删查改。
    * **串** 像一篇**文章**，我们更关心的是查找某个词语（子串）、替换某个句子（子串操作）。

---

#### **4.2 串的模式匹配**

本章的绝对核心，算法大题的潜在考点。

##### **4.2.1 简单的模式匹配算法（暴力法）**

* **重要考点**
    * 理解算法思想：主串指针 `i` 和模式串指针 `j` 双双前进，一旦失配，`i` **回溯**，`j` **归零**。
    * 知道其时间复杂度为 $O(nm)$，效率低下。

* **形象记忆法（笨拙的对答案）**
    * **主串** S 是一篇长文章，**模式串** T 是你要找的关键词。
    * **暴力法** 就是你把关键词的**第一个字**对准文章的第一个字，开始逐字比对。
    * **失配**：一旦有一个字对不上，你就把关键词整体**右移一个汉字**的位置，然后**从关键词的第一个字**重新开始和文章对。
    * **指针回溯**：`i = i - j + 2` 就是那个“把关键词移回文章下一个位置”的笨拙动作。

##### **4.2.2 KMP算法**

KMP算法是对暴力法的革命性优化，核心在于**主串指针 `i` 永不回溯**。

* **重要考点**
    * **KMP原理**：利用模式串自身的结构信息，在失配时不回溯主串指针，而是将模式串进行一次“**智能滑动**”。
    * **`next` 数组的计算**：这是手工计算的必考点。`next[j]` 的值代表当模式串的第 `j` 个字符与主串失配时，模式串指针 `j` 应该“回退”到的新位置。

* **形象记忆法（智能的对答案）**
    * **背景**：你还在对答案，但这次你变聪明了。
    * **已匹配部分**：假设你已经成功匹配了一段文字，如 `ababa`，但在下一个字符失配了。
    * **智能滑动**：你不会傻傻地只把关键词右移一位。你会分析 `ababa` 这段已匹配的内容，发现它的**前缀 `aba`** 和**后缀 `aba`** 是相同的。
    * **利用"最长相等前后缀"**：这个发现告诉你，主串中刚刚看过的那段 `...ababa...`，它的末尾三位是 `aba`。而你的关键词开头三位也是 `aba`。所以，你可以直接把关键词**大幅向右滑动**，让关键词的**前缀 `aba`** 对准主串中刚刚匹配上的**后缀 `aba`**，然后从失配的那个位置继续往下比较。
    * **`next` 数组**：就是你提前为关键词做好的一张“**失配滑动表**”。表中记录了在每个位置失配时，应该滑多远（即 `j` 应该跳转到哪个新位置）。

* **计算题解题模板（手算 `next` 数组）**

    **核心思想：自己匹配自己，找最长相等前后缀的长度。**
    (注：教材中 `next` 数组有多种定义，这里以王道书主流定义为例，即 `next[j]` 为 `T[1...j-1]` 的最长相等前后缀长度，且 `next[1]=0`)

    **题目**：求模式串 `T = "ababaa"` 的 `next` 数组。

    **模板（递推法）：**

    1.  **`next[1] = 0`**。这是规定。
    2.  **`next[2]`**：看 `T[1]`，即 `"a"`。前缀、后缀都为空。长度为0。`next[2]=1`。(若 `next[j]` 定义为 PM 值，则为 0)。
        * **更通用的定义下，`next[j]` 存储的就是 PM 值，所以是 0**
        * **以 `next` 值为跳转下标的定义：`next[1]=0`, `next[2]=1` (表示回到开头)**

        **我们采用最经典的 PM 值定义 `next[j] = k`，失配时 `j=k`**
        **`next[j]` 表示 `T[0...j-1]` 的最长相等前后缀长度。** (采用0-indexed)

        **模式串 T = "ababaa"**
        1.  `j=0`: `T[0]`='a'. next[0] = 0 (或-1，视定义).
        2.  `j=1`: `T[0...1]`="ab". 前缀'a', 后缀'b'. 不等. next[1] = 0.
        3.  `j=2`: `T[0...2]`="aba". 前缀'a', 后缀'a'. 相等，长度1. next[2] = 1. (`T[0]` == `T[2]`)
        4.  `j=3`: `T[0...3]`="abab". 前缀"ab", 后缀"ab". 相等，长度2. next[3] = 2. (`T[0...1]` == `T[2...3]`)
        5.  `j=4`: `T[0...4]`="ababa". 前缀"aba", 后缀"aba". 相等，长度3. next[4] = 3. (`T[0...2]` == `T[2...4]`)
        6.  `j=5`: `T[0...5]`="ababaa". 后缀'a'和前缀'a'匹配. 长度1. next[5]=1.

        **手推`next`数组的“代码模拟法”（1-based 数组，`next[1]=0`）**

        **模式串 T = 'a' 'b' 'a' 'b' 'a' 'a'** (下标 1..6)

        1.  `next[1] = 0` (规定)。
        2.  **求 `next[2]`** (`j=2`)：比较 `T[1]` 和 `T[j-1]=T[1]`？这没意义。`T[1]` 前缀为空。最长相等前后缀长度为0。`next[2]=1` (跳转到位置1)。
        3.  **求 `next[3]`** (`j=3`)：比较 `T[1]` 和 `T[2]` (`a` vs `b`)，不等。`next[3]=1`。
        4.  **求 `next[4]`** (`j=4`)：比较 `T[1]` 和 `T[3]` (`a` vs `a`)，相等！`next[4] = next[3]+1 = 2`？不对。应该是比较 `T[next[j-1]]` 和 `T[j-1]`
            * **正确手算法：**
            * **求`next[j]`的值 `k`:**
                * 看 `T[1...j-1]` 的最长相等前后缀 `T[1...k-1]` 和 `T[j-k...j-1]`
                * 那么 `next[j]` 就是 `k`。
            1. `next[1]=0`
            2. `j=2`, `T[1]='a'`, PMV=0, `next[2]=1`
            3. `j=3`, `T[1..2]="ab"`, PMV=0, `next[3]=1`
            4. `j=4`, `T[1..3]="aba"`, 'a'=='a', PMV=1, `next[4]=2`
            5. `j=5`, `T[1..4]="abab"`, "ab"=="ab", PMV=2, `next[5]=3`
            6. `j=6`, `T[1..5]="ababa"`, "aba"=="aba", PMV=3, `next[6]=4`

        **最终 `next` 数组 (王道定义): `0, 1, 1, 2, 3, 4`**

##### **4.2.3 KMP算法的进一步优化 (`nextval`)**

* **重要考点**
    * **优化动机**：当 `T[j] == T[next[j]]` 时，若 `T[j]` 失配，`T[next[j]]` 也必然失配，标准KMP会做一次无用的比较。
    * `nextval` 的思想就是跳过这种“必然失败”的比较。

* **形象记忆法（吃一堑，长一智）**
    * 标准 KMP 的滑动表 `next` 有时会“犯傻”。
    * **犯傻场景**：`T="aaaab"`, `next[4]=3`。当主串 `S[i]` 和 `T[4]`('a') 失配时，`next` 表说：“你跳转到 `j=3` 再试试”。但 `T[3]` 也是 'a'，明摆着还会失配。
    * **`nextval`** 就是更聪明的滑动表，它提前检查了这种情况。它会想：“既然 `T[4]` 和 `T[3]` 一样，那么 `next[4]` 的值不能是3，应该和 `next[3]` 的值一样”。
    * **规则**：`if (T[j] == T[next[j]]) nextval[j] = nextval[next[j]]; else nextval[j] = next[j];`

* **计算题解题模板（手算 `nextval` 数组）**

    1.  **第一步：先完整求出 `next` 数组。**
    2.  **第二步：逐位推导 `nextval` 数组。**
        * `nextval[1] = 0` (规定)。
        * 从 `j=2` 开始，依次计算 `nextval[j]`。
        * **对照公式**：
            * **例：T = "ababaa"**, `next` 数组为 `0, 1, 1, 2, 3, 4`
            * `nextval[1] = 0`
            * `j=2`: `T[2]='b'`, `next[2]=1`, `T[next[2]]='a'`. `T[2] != T[1]`. **`nextval[2] = next[2] = 1`**.
            * `j=3`: `T[3]='a'`, `next[3]=1`, `T[next[3]]='a'`. `T[3] == T[1]`. **`nextval[3] = nextval[1] = 0`**.
            * `j=4`: `T[4]='b'`, `next[4]=2`, `T[next[4]]='b'`. `T[4] == T[2]`. **`nextval[4] = nextval[2] = 1`**.
            * `j=5`: `T[5]='a'`, `next[5]=3`, `T[next[5]]='a'`. `T[5] == T[3]`. **`nextval[5] = nextval[3] = 0`**.
            * `j=6`: `T[6]='a'`, `next[6]=4`, `T[next[6]]='b'`. `T[6] != T[4]`. **`nextval[6] = next[6] = 4`**.
        * **最终 `nextval` 数组：`0, 1, 0, 1, 0, 4`**
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
