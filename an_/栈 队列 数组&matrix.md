<div style="float: left; width: 64%; padding: 1%;">

好的，同学们，第三章是数据结构中的“工具箱”，栈和队列是后续很多复杂算法（如图、树的遍历）的基础，而特殊矩阵的压缩存储是每年选择题的稳定考点。这一章内容不难，但概念和应用场景多，要求大家理解透彻，做到灵活运用。

下面，我们用最精炼的方式把本章考点一网打尽。

---

### **第3章 栈、队列和数组**

#### **3.1 栈 (Stack)**

##### **3.1.1 栈的基本概念**

* **重要考点**
    * 操作特性：**后进先出 (LIFO)**。
    * 合法的出栈序列判断。
    * n 个元素入栈，出栈序列种类数为**卡特兰数**：$\frac{1}{n+1}C_{2n}^{n}$。

* **形象记忆法（羽毛球筒）**
    * **栈** 就是一个羽毛球筒。
    * **入栈 (Push)**：往筒里放一个新球，只能放在**最上面**。
    * **出栈 (Pop)**：从筒里拿一个球，也只能拿**最上面**的那个。
    * **栈顶**：筒口；**栈底**：筒底。

* **解题模板 (判断出栈序列合法性)**
    * **题目**：入栈序列为 1, 2, 3, 4，判断 4, 3, 1, 2 是否是合法的出栈序列。
    * **模板 (模拟法)**：
        1.  **开一个空栈**。按入栈顺序处理元素。
        2.  **对照出栈序列**：当前想出栈的元素是 `4`。
        3.  **模拟入栈**：将 1, 2, 3, 4 依次入栈。栈内：`[1, 2, 3, 4]`。
        4.  **模拟出栈**：栈顶是 `4`，与期望出栈的 `4` 匹配，`4` 出栈。出栈序列：`4`。
        5.  **下一个期望出栈**：`3`。当前栈顶是 `3`，匹配，`3` 出栈。出栈序列：`4, 3`。
        6.  **下一个期望出栈**：`1`。当前栈顶是 `2`，不匹配。**且后续没有元素可以入栈了**。所以 `1` 无法在此刻出栈。
        7.  **结论**：`4, 3, 1, 2` 不是合法序列。
    * **核心规律**：在出栈的任意一个元素后面，所有比它**先入栈**且**还未出栈**的元素，必须以**逆序**出栈。 (例如，`4, 3, 1, 2` 中 `1` 在 `2` 前面出栈，但 `1` 比 `2` 先入栈，这是不可能的)。

##### **3.1.2 栈的顺序存储结构（顺序栈）**

* **重要考点**
    * 栈顶指针 `top` 的两种定义方式及对应的判空/判满条件。
    * **共享栈**：两个栈共享一个数组，一个栈底在头，一个栈底在尾，栈顶相对增长。
        * **栈满条件**：`top1 - top0 == 1`。

* **形象记忆法（弹夹）**
    * **顺序栈** 就是一个弹夹。
    * `top` 指针就是弹夹的**托弹板**。
    * **定义1 (top指向栈顶元素)**：`top` 初始为 `-1`。
        * **入栈**：托弹板**先上移一位** (`++top`)，再把子弹放上去 (`data[top]=x`)。
        * **判满**：`top == MaxSize - 1` (托弹板到顶了)。
    * **定义2 (top指向下一个可插入位置)**：`top` 初始为 `0`。
        * **入栈**：子弹**先放进去** (`data[top]=x`)，托弹板再上移 (`top++`)。
        * **判满**：`top == MaxSize` (托弹板顶到头了)。

##### **3.1.3 栈的链式存储结构（链栈）**

* **重要考点**
    * 用**单链表的头插法和头删法**实现，永远在链表头部操作。
    * 不存在栈满的情况。

* **形象记忆法（叠罗汉）**
    * **链栈** 就是一队在叠罗汉的人。
    * **入栈**：新来一个人，直接叠在**最上面**（头插法）。
    * **出栈**：最上面的人先下来（头删法）。

---

#### **3.2 队列 (Queue)**

##### **3.2.1 队列的基本概念**

* **重要考点**
    * 操作特性：**先进先出 (FIFO)**。
    * 队头（Front）出队，队尾（Rear）入队。

* **形象记忆法（排队打饭）**
    * **队列** 就是食堂打饭的队伍。
    * **入队 (EnQueue)**：新来一个同学，排在**队尾**。
    * **出队 (DeQueue)**：打好饭的同学，从**队头**离开。

##### **3.2.2 队列的顺序存储结构（循环队列）**

* **重要考点**
    * 解决“**假溢出**”问题。（队伍前面的人走了，但后面的人没跟上，导致队尾的人以为没位置了）。
    * **判空与判满的条件**是绝对核心。
    * 指针移动取模运算：`front = (front + 1) % MaxSize`。

* **形象记忆法（圆形餐桌）**
    * **循环队列** 就是一个圆形的旋转餐桌。
    * `front` 指针是**取餐处**，`rear` 指针是**放餐处**。
    * 指针移动：`% MaxSize` 确保指针到头后能绕回起点。

* **解题模板 (循环队列判空/判满)**
    * **模板1：牺牲一个存储单元** (最常用)
        * **队满**：`(Q.rear + 1) % MaxSize == Q.front` (放餐处马上要追上取餐处了)。
        * **队空**：`Q.rear == Q.front` (放餐处和取餐处在同一位置)。
        * **队列长度**：`(Q.rear - Q.front + MaxSize) % MaxSize`。
    * **模板2：设置 `size` 变量**
        * **队满**：`Q.size == MaxSize`。
        * **队空**：`Q.size == 0`。
    * **模板3：设置 `tag` 标志位**
        * `tag=0`表示上次是出队，`tag=1`表示上次是入队。
        * **队满**：`Q.rear == Q.front && tag == 1`。
        * **队空**：`Q.rear == Q.front && tag == 0`。

##### **3.2.3 & 3.2.4 队列的链式存储及双端队列**
* **链队列**：带**头指针 `front`** 和**尾指针 `rear`** 的链表，方便在两端进行 $O(1)$ 操作。
    * `front` 指向头结点，`rear` 指向最后一个元素结点。
    * **出队**：操作 `front->next`。
    * **入队**：操作 `rear`。
* **双端队列**：两端都能进出的“**万能队列**”。
    * **输入受限**：一端只能出，另一端能进能出。(像一个栈和一个队列的组合)。
    * **输出受限**：一端只能进，另一端能进能出。

---

#### **3.3 栈和队列的应用**

* **重要考点**
    * **栈**：与“**最近相关性**”、“**逆序**”、“**匹配**”有关的问题。
    * **队列**：与“**按顺序处理**”、“**分层**”、“**公平等待**”有关的问题。

* **应用场景模板**
    * **括号匹配 (栈)**：
        * `遇到左括号` -> `入栈`
        * `遇到右括号` -> `取栈顶`，若匹配则 `出栈`，不匹配则 `失败`。
        * `结束时` -> 若`栈空`则 `成功`，否则 `失败`。
    * **表达式求值 (栈)**：
        * **中缀转后缀**：操作数直接输出；运算符与栈顶比较优先级，高则入，低则出。
        * **后缀求值**：操作数入栈；运算符则 `pop` 两个数运算，结果再 `push` 回去。
    * **递归 (栈)**：函数调用本身就是个压栈、出栈的过程（函数调用栈）。
    * **树的层次遍历 (队列)**：
        1.  根结点 `入队`。
        2.  `while(队列不空)`:
            * 结点 `出队` 并访问。
            * 将其**左右孩子**依次 `入队`。
    * **操作系统 (队列)**：CPU 任务调度、打印机缓冲池，都是典型的 FIFO 队列应用。

---

#### **3.4 数组和特殊矩阵**

这部分是**计算题**高发区，核心是**地址计算**和**下标转换**公式。

* **重要考点**
    * 多维数组按**行优先**或**列优先**的地址计算。
    * 对称矩阵、三角矩阵、三对角矩阵的压缩存储下标转换公式。
    * 稀疏矩阵的三元组表示。

* **计算题解题模板 (压缩存储)**

    **核心：搞清楚 `(i, j)` 前面有多少个元素。** (以下公式均假设数组下标从0开始，矩阵行列号从1开始)

    * **1. 对称矩阵 (存下三角)**
        * **思想**：`A[i][j]` 对应一维数组 `B[k]`。`k` 的值等于它前面所有行（`i-1`行）的元素总数，加上它在本行（第`i`行）的位置（`j-1`）。
        * **公式**：$k = \frac{i(i-1)}{2} + (j-1)$  (其中 $i \geq j$)

    * **2. 上/下三角矩阵 (存非公用常量部分)**
        * **上三角**：$k = \frac{(i-1)(2n-i+2)}{2} + (j-i)$
        * **下三角**：同对称矩阵。
        * **记忆技巧**：公式复杂，考场上建议**现场推导**，思路同对称矩阵。

    * **3. 三对角矩阵**
        * **思想**：`A[i][j]` 前面有 `i-1` 行。第1行有2个元素，中间的 `i-2` 行每行有3个元素。
        * **元素总数 (在 `A[i][j]` 前)**：$2 + 3 \times (i-2) + (j - (i-1)) = 2i+j-3$ (当 $i > 1$)。
        * **公式**：$k = 2i+j-3$ (其中 $|i-j| \leq 1$)

    * **稀疏矩阵**
        * **三元组**：`(行, 列, 值)`。
        * **存储**：用一个结构数组存所有非零元素的三元组，外加矩阵的行数、列数、非零元个数。
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
