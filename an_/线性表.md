<div style="float: left; width: 64%; padding: 1%;">

好的，同学们，第二章线性表是数据结构的“腰”，承上启下，也是每年算法大题的命题重点。这一章必须做到滚瓜烂熟。记住，线性表的题，代码量不大，但对**效率**（时间/空间复杂度）的要求极高，我们的目标是写出最优解。

请跟紧我的思路，我们把这一章拆解透彻。

---

### **第2章 线性表**

#### **2.1 线性表的定义和基本操作**

这部分是基础概念，主要出选择题，理解定义和特点即可。

* **重要考点**
    * 线性表的逻辑特性：“一对一”关系、有限、同类型。
    * 线性表是**逻辑结构**，顺序表和链表是其**存储结构**。

* **形象记忆法（排队做核酸）**
    * **线性表** 就是这只队伍本身（逻辑上的队伍）。
        * **有限**：队伍人数是有限的。
        * **同类型**：都是“人”，不能混进来一只猫。
        * **一对一**：除了队首和队尾，每个人前面只有一个人，后面也只有一个人。
    * **基本操作** 就是对这只队伍能做的管理工作：
        * `InitList`：拉起一条隔离带，准备开始排队。
        * `ListInsert`：有人来了，安排插队到第 `i` 个位置。
        * `ListDelete`：第 `i` 个人做完了，离开队伍。
        * `GetElem`：查看第 `i` 个人是谁。
        * `LocateElem`：找到叫“张三”的同学在哪个位置。

---

#### **2.2 线性表的顺序表示（顺序表）**

顺序表是线性表最直观的实现，考题中常涉及在数组上进行高效操作。

* **重要考点**
    * 随机存取特性。
    * 插入、删除操作的时间复杂度分析。
    * 插入、删除操作中元素的移动方式。

* **形象记忆法（电影院的一排座位）**
    * **顺序表** 就是电影院里一排**连续的、有编号的**座位。
        * **存储结构**：座位物理上挨在一起，`data[0]`挨着`data[1]`。
        * **随机存取 $O(1)$**：给你票（位序 `i`），你能立刻找到座位（`data[i-1]`），速度飞快。
        * **插入 $O(n)$**：想在中间加个座位？那你屁股后面**所有的人**都得站起来，往后挪一个位置。
        * **删除 $O(n)$**：中间有个人离场？他屁股后面**所有的人**都得往前挪一个位置，把空位补上。

* **计算题与代码题解题模板**

    **核心：搞清楚元素移动的方向和范围。**

    * **模板：在第 `i` 个位置插入元素 `e`**
        1.  **思想**：从后往前，依次“挪屁股”，给第 `i` 个位置腾出空间。
        2.  **步骤**：
            * 判断 `i` 的合法性 (`1 <= i <= L.length + 1`)。
            * 从**表尾** `L.length-1` 开始，到要插入的**位置** `i-1` 结束，所有元素向后移动一位。
            * `for (int j = L.length; j >= i; j--) L.data[j] = L.data[j-1];` (注意数组下标)
            * 将 `e` 放入 `L.data[i-1]`。
            * `L.length++`。
        3.  **复杂度**：平均移动 $n/2$ 个元素，时间复杂度 $O(n)$。

    * **模板：删除第 `i` 个位置的元素**
        1.  **思想**：从前往后，依次“向前看齐”，把第 `i` 个位置的坑填上。
        2.  **步骤**：
            * 判断 `i` 的合法性 (`1 <= i <= L.length`)。
            * 从要删除位置的**下一个** `i` 开始，到**表尾** `L.length-1` 结束，所有元素向前移动一位。
            * `for (int j = i; j < L.length; j++) L.data[j-1] = L.data[j];`
            * `L.length--`。
        3.  **复杂度**：平均移动 $(n-1)/2$ 个元素，时间复杂度 $O(n)$。

---

#### **2.3 线性表的链式表示（链表）**

链表是本章的绝对核心，算法题的“兵家必争之地”，重点掌握指针操作。

* **重要考点**
    * **指针**或**引用**的修改。
    * **带头结点**的好处（统一操作，处理空表和非空表、首元结点和非首元结点的逻辑一致）。
    * 各种链表（单、双、循环）的插入和删除操作。
    * **双指针法**解决复杂链表问题。

* **形象记忆法（寻宝游戏）**
    * **链表** 就是一场寻宝游戏，每个**藏宝点（结点）**都有一份**宝藏（数据域）**和一张指向**下一个藏宝点（指针域 next）**的地图。
        * **头指针 `L`**：寻宝游戏的**起点地图**。
        * **头结点**：一个**不放宝藏**的“起始站”，只提供第一张地图。有了它，不管是在第一个藏宝点还是中间插入新点，操作流程都一样，非常方便。
        * **查找 $O(n)$**：想找第 `i` 个宝藏，必须从起点出发，按地图一张一张找过去。
        * **插入/删除 $O(1)$ (找到位置后)**：想在 A 和 B 之间加一个 C 点，只需要把 A 点的地图改成指向 C，再把 C 点的地图指向 B 即可。这个“改地图”的动作本身很快。

* **代码题解题模板**

    **核心：指针操作的“先连后断”原则，画图是王道！**

    ##### **2.3.1 & 2.3.2 单链表**

    * **模板：在 `p` 结点后插入 `s` 结点 (后插)**
        1.  **画图**： `p -> (p的后继)`
        2.  **思想**：`s` 要插在 `p` 和 `p->next` 之间。
        3.  **步骤 (两步)**：
            * `s->next = p->next;`  // **① 新来的先认好后家**
            * `p->next = s;`        // **② 前面的再接纳新人**
            * **切记**：顺序不能反！否则 `p` 的后继结点会丢失。

    * **模板：删除 `p` 结点的后继结点 `q`**
        1.  **画图**：`p -> q -> (q的后继)`
        2.  **思想**：让 `p` 直接跳过 `q`，连接到 `q` 的后继。
        3.  **步骤 (两步)**：
            * `q = p->next;`          // 临时指针 `q` 指向要被删除的结点。
            * `p->next = q->next;`    // **① 断开前面的链，并连接到后面**
            * `free(q);`              // **② 释放被孤立的结点**

    * **模板：双指针法 (快慢指针)**
        * **应用场景**：寻找链表中点、判断是否有环、找倒数第k个结点等。
        * **思想**：设置两个指针 `fast` 和 `slow`，都从头开始。`fast` 每次走两步，`slow` 每次走一步。
        * **找中点**：当 `fast` 走到表尾时，`slow` 正好在中间。

    ##### **2.3.3 双链表**
    * **形象记忆**：每个藏宝点（结点）有**两张地图**，一张指向**下一个** (`next`)，一张指回**上一个** (`prior`)。
    * **模板：在 `p` 和 `p->next` 之间插入 `s` 结点**
        1.  **画图**：`p <-> p->next`
        2.  **思想**：需要修改4个指针，形成 `p <-> s <-> p->next` 的双向连接。
        3.  **步骤 (四步)**：
            * `s->next = p->next;`        // ① s 的后继指向 p 的后继
            * `p->next->prior = s;`      // ② p 的后继的前驱指向 s
            * `s->prior = p;`            // ③ s 的前驱指向 p
            * `p->next = s;`            // ④ p 的后继指向 s

    ##### **2.3.4 循环链表**
    * **形象记忆**：寻宝游戏的地图形成一个**圈**，最后一个藏宝点指向了起始站。
    * **考点**：
        * **判空条件**：`L->next == L` (带头结点的循环链表)。
        * **遍历结束条件**：`p->next != L` (p 不等于头指针)。
        * **尾指针操作**：用尾指针 `rear` 可以 $O(1)$ 时间找到表头 (`rear->next`) 和表尾 (`rear`)，合并两个链表非常方便。

##### **2.3.6 顺序表 vs 链表 (选择题高频考点)**

**一句话总结：按位置访问多，用顺序表；增删改频繁，用链表。**

| 特性 | 顺序表 (电影院座位) | 链表 (寻宝游戏) |
| :--- | :--- | :--- |
| **存取方式** | **随机存取 $O(1)$** (强) | 只能顺序存取 $O(n)$ (弱) |
| **插入/删除** | 移动元素 $O(n)$ (弱) | **修改指针 $O(1)$** (强) *不含查找* |
| **空间分配** | 连续空间，易产生碎片 | 零散空间，按需分配 (灵活) |
| **存储密度** | 高，无额外开销 | 低，有指针域开销 |
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
