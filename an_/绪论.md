<div style="float: left; width: 64%; padding: 1%;">

好的，各位同学，我们开始第一章的学习。这一章是数据结构的基础，重点是**算法的时间复杂度和空间复杂度分析**，这是每年必考的知识点，必须做到白给分。

请大家跟着我的思路，我们把核心考点用最直白的方式梳理清楚，做到看一眼就能记住，拿到题就能套用。

-----

### **第1章 绪论**

#### **1.1 数据结构的基本概念**

##### **1.1.1 基本概念和术语**

这部分主要是选择题考点，理解层次关系即可。

  * **重要考点**

      * 数据、数据元素、数据项的层次关系。
      * 数据结构、数据类型、抽象数据类型（ADT）的区分。

  * **形象记忆法**

      * 把整个**学生信息表**想象成 **数据(Data)**。
          * **数据对象 (Data Object)**：表里的**所有男生**，是性质相同的数据元素的集合。
          * **数据元素 (Data Element)**：表中的**每一行**（一个学生的完整信息），是数据的基本单位。
          * **数据项 (Data Item)**：表中的**某个单元格**（如“张三”、“男”），是不可分割的最小单位。
      * **抽象数据类型 (ADT)**：把它想成一个\*\*“黑盒子”**或者电器的**“操作面板”\*\*。
          * **举例**：我们操作电脑，只需要知道按开机键（操作）电脑就会开机（功能），不需要关心内部电路是怎么实现的（内部实现）。ADT就是这样，它只告诉你这个数据能干什么（操作），但不告诉你具体怎么干（实现）。

##### **1.1.2 数据结构三要素**

这是整个数据结构课程的核心框架，也是大题中经常需要分析的角度。

  * **重要考点**

      * 逻辑结构与存储结构的联系和区别。
      * 四种基本逻辑结构。
      * 四种基本存储结构。

  * **形象记忆法（盖房子模型）**

      * **1. 逻辑结构 (设计图纸)**：数据元素之间的**关系**。图纸上画好了，卧室挨着客厅，卫生间对着门。这只是**设计**，和用什么材料盖无关。

          * **集合**：元素间“同在一个屋檐下”，没别的关系。（一堆独立的砖块）
          * **线性结构**：元素“手拉手”排队，一对一。（糖葫芦）
          * **树形结构**：一个领导管多个下属，一对多。（公司组织架构）
          * **图状结构**：多个朋友互相认识，多对多。（微信朋友圈）

      * **2. 存储结构 (施工方案)**：逻辑结构在计算机里的**实现方式**。图纸设计好了，现在要考虑用什么材料、怎么施工。

          * **顺序存储**：**排排坐**。按顺序把人安排在连续的座位上。
              * **优点**：找人快（知道排号直接定位）。
              * **缺点**：来新人想插队难，中间有人走了座位就空着浪费。
          * **链式存储**：**手拉手**。座位随便坐，每个人记住自己下一个朋友的位置（通过指针）。
              * **优点**：插队、离队方便。
              * **缺点**：找人慢（得从第一个人开始一个一个问过去）。
          * **索引存储**：**书的目录**。除了书本身（数据），额外做个目录（索引表），记录每个章节在哪一页。
              * **优点**：查找速度极快。
              * **缺点**：额外需要目录的空间，更新内容时目录也要改。
          * **散列存储 (哈希)**：**快递柜**。根据手机号（关键字）通过一个函数直接算出快递柜编号（存储地址）。
              * **优点**：增删查改都接近 $O(1)$，神速。
              * **缺点**：可能出现两个人手机号算出来是同一个柜子（冲突），解决冲突需要额外操作。

      * **3. 数据的运算 (房子的功能)**：对房子能做的操作。

          * **运算定义**：在\*\*设计图纸（逻辑结构）\*\*上定义，比如“增加一个房间”、“查询客厅大小”。
          * **运算实现**：在\*\*施工方案（存储结构）\*\*上实现，具体怎么拆墙、砌墙。

  * **解题模板 (简答/分析题)**

      * **问：请分析XX数据结构的特点。**
      * **答题模板**：
        1.  **逻辑结构**：该结构属于...（线性/树/图）结构，元素之间是...（一对一/一对多/多对多）关系。
        2.  **存储结构**：通常采用...（顺序/链式）存储。
              * 若为顺序存储，则...（优点：随机存取；缺点：插入删除慢）。
              * 若为链式存储，则...（优点：插入删除快；缺点：只能顺序存取）。
        3.  **基本运算**：支持...（如查找、插入、删除）等操作，其效率...。

-----

#### **1.2 算法和算法评价**

本章的绝对核心，计算题的重灾区。

##### **1.2.1 算法的基本概念**

  * **重要考点**

      * 算法的五个重要特性：**有穷性、确定性、可行性、输入、输出**。

  * **形象记忆法 (做菜的菜谱)**

      * **有穷性**：步骤必须是有限的，不能让你“一直炒下去”。
      * **确定性**：每一步都是明确的，比如“放5克盐”，而不是“放少许盐”。
      * **可行性**：每一步都能做到，比如“把菜放进锅里”，而不是“把大象放进冰箱里”。
      * **输入**：你准备的食材（可以没有输入，比如算法是“凭空输出一个Hello World”）。
      * **输出**：做好的那道菜（必须有输出）。

##### **1.2.2 算法效率的度量**

  * **重要考点**

      * 时间复杂度的计算（大O表示法）。
      * 空间复杂度的计算。

  * **最简解释**

      * **时间复杂度**：不是算程序运行了多少秒，而是算**基本操作的执行次数**随问题规模 $n$ 变化的**增长趋势**。我们只关心**最影响效率**的那段代码。
      * **空间复杂度**：算算法需要**额外**使用的**辅助空间**随问题规模 $n$ 变化的增长趋势。

  * **计算题解题模板 (时间复杂度)**

    **核心思想：找基本语句 -\> 算执行次数 -\> 取最高阶**

    -----

    **类型一：循环变量与循环条件相关 (如 `i=i*2`, `i=i-j`)**

    **模板：设基本语句执行次数为 $t$，找循环变量与 $t$ 的关系，代入循环结束条件求解 $t$。**

      * **【例1】`for(i=1; i<=n; i=i*2)`**

        1.  **基本语句**: `i=i*2`。
        2.  **设执行次数**: 设循环体执行了 $t$ 次。
        3.  **找关系**: 第 $t$ 次循环后，$i$ 的值为 $2^t$。
        4.  **代入结束条件**: 循环结束时，满足 $2^t \> n$。
        5.  **求解**: $t \> \\log\_2 n$。
        6.  **结论**: 时间复杂度为 $T(n) = O(\\log\_2 n)$。

      * **【例2】`for(i=n; i>1; i=i/2)`**

        1.  **基本语句**: `i=i/2`。
        2.  **设执行次数**: 设循环体执行了 $t$ 次。
        3.  **找关系**: 第 $t$ 次循环后，$i$ 的值为 $n/2^t$。
        4.  **代入结束条件**: 循环结束时，满足 $n/2^t \\le 1$。
        5.  **求解**: $n \\le 2^t$，即 $t \\ge \\log\_2 n$。
        6.  **结论**: 时间复杂度为 $T(n) = O(\\log\_2 n)$。

    -----

    **类型二：循环变量与循环条件无关 (多层嵌套循环)**

    **模板：由内向外分析，用乘法法则；或直接用数学求和。**

      * **【例1】**

        ```c
        for (i=1; i<=n; i++) {
            for (j=1; j<=n; j++) {
                // ... O(1)
            }
        }
        ```

        1.  **内层循环**: 对于每个 `i`，执行 `n` 次。
        2.  **外层循环**: `i` 从 1 到 `n`，执行 `n` 次。
        3.  **总次数**: $n \\times n = n^2$。
        4.  **结论**: $T(n) = O(n^2)$。

      * **【例2】**

        ```c
        for (i=1; i<=n; i++) {
            for (j=1; j<=i; j++) {
                // ... O(1)
            }
        }
        ```

        1.  **内层循环**: 对于每个 `i`，执行 `i` 次。
        2.  **总次数 (求和)**: 当 $i=1$ 时，内层执行1次；$i=2$ 时，执行2次... $i=n$ 时，执行 $n$ 次。总次数为 $1+2+3+\\dots+n = \\frac{n(n+1)}{2} = \\frac{1}{2}n^2 + \\frac{1}{2}n$。
        3.  **取最高阶**: 保留最高阶项 $n^2$。
        4.  **结论**: $T(n) = O(n^2)$。

    -----

    **类型三：递归算法**

    **模板：写出递推关系式 -\> 求解。**

      * **【例】求 n\! 的递归算法 `fact(n)`**
        ```c
        int fact(int n) {
            if (n <= 1) return 1;
            return n * fact(n-1); // 基本操作
        }
        ```
        1.  **递推关系**: 求解 `fact(n)` 需要调用一次 `fact(n-1)`，外加一次乘法操作。所以 $T(n) = T(n-1) + O(1)$。
        2.  **求解**:
            $T(n) = T(n-1) + 1$
            $= T(n-2) + 1 + 1$
            $= \\dots$
            $= T(1) + (n-1) = 1 + n - 1 = n$
        3.  **结论**: 时间复杂度为 $T(n) = O(n)$。

  * **代码题解题模板 (空间复杂度)**

    **核心思想：看算法执行过程中，有没有申请与 n 相关的辅助空间。**

      * **$O(1)$**：只用了**常数**个变量，与问题规模 $n$ 无关。这是最优情况，也叫“原地工作”。
        ```c
        void swap(int &a, int &b){
            int temp = a; // 申请了1个辅助变量
            a = b;
            b = temp;
        } // S(n) = O(1)
        ```
      * **$O(n)$**：申请了**一维数组**或进行了 $n$ 次**递归**。
          * **申请数组**:
            ```c
            void func(int n) {
                int a[n]; // 申请了长度为n的数组
                // ...
            } // S(n) = O(n)
            ```
          * **递归调用**: 每次递归调用都需要一个栈帧来保存现场，递归深度为 $n$ 时，空间复杂度就是 $O(n)$。
            ```c
            int fact(int n) {
                if (n <= 1) return 1;
                return n * fact(n-1); // 递归深度为n
            } // S(n) = O(n)
            ```
      * **$O(n^2)$**：申请了**二维数组**。
        ```c
        void func(int n) {
            int matrix[n][n]; // 申请了n*n的二维数组
            // ...
        } // S(n) = O(n^2)
        ```

-----

**本章总结：**

1.  **概念**：搞清楚三要素（逻辑、存储、运算）的“盖房子”模型。
2.  **计算**：牢记时间复杂度的三种计算模板，尤其是嵌套循环和递归。空间复杂度看是否申请了和 $n$ 相关的额外空间。
3.  **方法**：拿到一个算法，先看有没有循环，再看循环怎么结束，套用模板即可。递归问题，先写递推式。

第一章内容不难，但非常重要，是后续所有章节的基础。务必把时间复杂度的计算练到炉火纯青。
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
