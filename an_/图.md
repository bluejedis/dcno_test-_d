<div style="float: left; width: 64%; padding: 1%;">

好的，同学们，第六章“图”是数据结构中**最复杂**的结构，也是算法思想的集大成者。图论的算法难度较大，但考研的重点非常突出：**遍历（DFS、BFS）是核心，应用算法（最小生成树、最短路径、拓扑排序、关键路径）重在理解思想和手工模拟过程。**

请大家务必跟紧思路，本章内容我们不求深究代码，但求把每种算法的执行过程刻在脑子里。

---

### **第6章 图**

#### **6.1 图的基本概念**

这部分是基础，选择题考点，用于理解图的语言。

* **重要考点**
    * 图的组成：顶点集 `V` (非空) 和边集 `E`。
    * **有向图** vs **无向图**。
    * **度**、**入度**、**出度**的概念及关系：无向图度之和 = 2|E|；有向图入度之和 = 出度之和 = |E|。
    * **连通图** (无向)、**强连通图** (有向)。
    * **连通分量** (无向图的极大连通子图)、**生成树** (连通图的极小连通子图)。

* **形象记忆法（朋友圈/交通网络）**
    * **图**：就是一个**朋友圈**或**城市交通网**。
    * **顶点(Vertex)**：朋友圈里的**每个人**或地图上的**城市**。
    * **边(Edge)**：人与人之间的**好友关系**或城市间的**道路**。
        * **无向图**：微信好友关系，互为好友。
        * **有向图**：微博关注关系，你关注他不代表他关注你。
    * **度**：一个人的**好友数量**。
        * **出度**：你**关注**了多少人。
        * **入度**：有多少**粉丝**关注你。
    * **连通图**：朋友圈里，**任意两个人**之间都能通过“好友的好友”联系上。
    * **生成树**：用**最少的道路**连接所有城市，保证每个城市都能互相到达。道路数量 = 城市数量 - 1。

---

#### **6.2 图的存储及基本操作**

这是后续所有算法的基础，不同的存储方式决定了算法的效率。

* **重要考点**
    * **邻接矩阵**：优缺点，适用场景（稠密图）。
    * **邻接表**：优缺点，适用场景（稀疏图）。

* **形象记忆法**
    * **1. 邻接矩阵 (航班时刻表)**
        * **是什么**：一个二维表格，行和列都是城市，表格内容是两个城市间**是否有直飞航班**（或机票价格）。
        * **优点**：查询任意两个城市 `A` 到 `B` 是否有直飞，**非常快**（$O(1)$），看一眼表格就行。
        * **缺点**：如果城市很多但航班很少（稀疏图），这个表格会**巨大且非常空**，浪费纸张（空间复杂度 $O(|V|^2)$）。
    * **2. 邻接表 (公交线路图)**
        * **是什么**：一张列表，列出每个城市，后面跟着一个链表，记录从这个城市**能直接到达**的所有城市。
        * **优点**：只记录存在的航线，**非常省空间**（空间复杂度 $O(|V|+|E|)$）。
        * **缺点**：想知道 `A` 到 `B` 有没有直飞，你得在 `A` 市的站牌上把所有线路都看一遍，**比较慢**。

---

#### **6.3 图的遍历**

遍历是图算法的灵魂，是后续所有应用算法的基础。

* **重要考点**
    * **广度优先搜索 (BFS)**：核心是**队列**，实现**层序遍历**。
    * **深度优先搜索 (DFS)**：核心是**递归 (栈)**，实现“一条路走到黑”的探索。
    * 两种遍历的时间复杂度：邻接矩阵 $O(|V|^2)$，邻接表 $O(|V|+|E|)$。

* **形象记忆法**
    * **广度优先搜索 (BFS - 投石问路)**
        * **思想**：像往水里扔一块石头，波纹从中心**一圈一圈**向外扩散。
        * **过程**：从起点 `A` 出发，先访问所有与 `A` 直接相连的朋友（第1层），再通过他们去访问所有与他们直接相连的、你还没访问过的朋友（第2层），以此类推。
        * **工具**：需要一个**队列 (排队)**，先把第一层的朋友请进队列，然后让他们按顺序出队，“介绍”他们的朋友入队。
        * **应用**：求**无权图**的单源最短路径。
    * **深度优先搜索 (DFS - 勇闯迷宫)**
        * **思想**：像走迷宫，认准一条路就**一直走到底**。
        * **过程**：从起点 `A` 出发，随便找一个邻居 `B` 深入探索，再从 `B` 找一个邻居 `C` 继续深入...直到走到“死胡同”（没有未访问的邻居了），然后**原路返回**到上一个路口，看有没有别的岔路可以走。
        * **工具**：**递归 (函数调用栈)**，每次深入探索就是一次新的函数调用，返回就是函数出栈。

---

#### **6.4 图的应用**

本章的应用算法是考研的重头戏，必须掌握手工模拟过程。

* **解题模板核心**：**贪心策略**。每一步都做出当前看起来最优的选择。

##### **6.4.1 最小生成树 (MST)**

* **目标**：用**最低的成本**连接所有顶点。
* **形象记忆**：村村通工程，如何在所有村庄之间铺设光缆，使得总长度最短。

* **模板1：Prim (普里姆) 算法 (加点法)**
    1.  **思想**：从一个顶点开始，不断将**离当前集合最近**的顶点拉拢进来。
    2.  **步骤**：
        * 任选一个顶点（如 `v1`）作为起点，放入集合 `U`。
        * 重复 `n-1` 次：
            * 在连接 `U` 内顶点和 `U` 外顶点的所有边中，找到**权值最小**的那条边 `(u, v)` (其中 `u` in `U`, `v` not in `U`)。
            * 将这条边和顶点 `v` 加入 `U`。
    * **适合**：**稠密图**。

* **模板2：Kruskal (克鲁斯卡尔) 算法 (加边法)**
    1.  **思想**：不问顶点，只看边，永远选择**当前能选的、最便宜的**边。
    2.  **步骤**：
        * 将所有边按**权值从小到大排序**。
        * 依次考察每一条边 `(u, v)`：
            * 如果 `u` 和 `v` **已经连通**（加入这条边会形成环），则**舍弃**。
            * 否则，**选择**这条边。
        * 重复直到选出 `n-1` 条边。
    * **适合**：**稀疏图**。

##### **6.4.2 最短路径**

* **目标**：找到从一个顶点到其他顶点（或所有顶点之间）的最短路径。
* **形象记忆**：GPS导航，规划最短的行车路线。

* **模板1：Dijkstra (迪杰斯特拉) 算法 (单源最短路径)**
    1.  **思想**：与Prim类似，但贪心标准不同。每次选择**离源点最近**的顶点。**不能处理负权边**。
    2.  **步骤**：
        * 初始化：源点 `v0` 放入集合 `S`，`dist` 数组记录 `v0` 到各点的初始距离。
        * 重复 `n-1` 次：
            * 从 `S` 外的顶点中，选出 `dist` 值**最小**的顶点 `u`，加入 `S`。
            * **松弛操作**：以 `u` 为中介，更新 `v0` 到 `S` 外其他顶点的距离。（如果 `v0->u->v` 比 `v0->v` 更短，则更新 `dist[v]`）。

* **模板2：Floyd (弗洛伊德) 算法 (所有顶点对最短路径)**
    1.  **思想**：动态规划。依次让每个顶点 `k` 作为“中转站”，尝试优化任意两点 `i, j` 间的路径。**可以处理负权边（但不能有负权回路）**。
    2.  **核心公式**：
        `for k from 1 to n:`
            `for i from 1 to n:`
                `for j from 1 to n:`
                    `D[i][j] = min(D[i][j], D[i][k] + D[k][j])`
    3.  **记忆**：三层循环，`k` 在最外层。含义是：“从`i`到`j`，是直接走近，还是绕道`k`更近？”

##### **6.4.4 拓扑排序**

* **目标**：为**有向无环图 (DAG)** 的顶点排一个线性序列，保证所有任务的前后依赖关系。
* **形象记忆**：大学课程的先修关系图，拓扑排序就是一份**合法的修课顺序**。

* **模板：Kahn 算法**
    1.  **准备**：计算所有顶点的**入度**。
    2.  **开始**：将所有**入度为0**的顶点放入一个**队列（或栈）**。
    3.  **循环**：
        * 从队列中取出一个顶点 `u`，输出。
        * 遍历 `u` 的所有邻接点 `v`：
            * 将边 `(u, v)` “删除”，即 `v` 的**入度减1**。
            * 如果 `v` 的入度变为0，则将 `v` **入队**。
    4.  **结束**：如果输出的顶点数小于总顶点数，说明**图中存在环**。

##### **6.4.5 关键路径**

* **目标**：在**带权有向无环图 (AOE网)** 中，找到决定项目**总工期**的路径。
* **形象记忆**：大型项目（如造火箭）的任务流程图。关键路径是那些**一点都不能耽误**的任务链。

* **计算模板**：
    1.  **正向拓扑，算最早发生时间 `ve(k)`**：`ve(k) = Max{ve(j) + Weight(j, k)}` (所有指向k的活动)。
    2.  **逆向拓扑，算最迟发生时间 `vl(k)`**：`vl(k) = Min{vl(j) - Weight(k, j)}` (所有从k出发的活动)。
    3.  **计算活动的时间余量**：`余量 = l(i) - e(i) = vl(终点) - ve(起点) - Weight(起点,终点)`。
    4.  **关键活动**：时间余量为**0**的活动。
    5.  **关键路径**：由**关键活动**构成的从源点到汇点的路径。
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
