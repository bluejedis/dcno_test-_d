# 线性表
- base operation
    - define
    - 参数
        - whether need 被改动 in函数内
            - Y
                - 传递 指针(指向parameter
            - N
                - 直接传递
    - --
- 顺序表
    - >数组实现
        - ![Screenshot_2025-09-24-18-51-40-459_com](https://bluejedis.github.io/picx-images-hosting/ds/Screenshot_2025-09-24-18-51-40-459_com.microsoft.emmx.canary-edit.6m49owjst9.jpg)
        - discern
            - 数组
                - 一维数组，元素can不连续存放
                - 表示
                    - 栈、队列、树etc
    - base
        - 3base属性
            - 起始位置
            - 数组length(存储空间)
                - range: [1,n+1]
                    - <span style="color:lightgray">?线性表元素的序号是从1开始,而在第n+1个位置插入相当于在表尾追加。←不是从0吗？</span>
            - 线性表..
                - ≤数组..
        - code
        - 地址
            - >every 存储单元'编号
            - **随机存取**结构
                - >$\Omicron (1)$
                    - <span style="color:lightgray">存取第i个元素&其前驱和后继元素的值</span>
                    - discern：
                        - 链表：从头结点 顺序查找
                            - $O(n)$
                        - only 顺序表 
                            - can 按序号随机
                            - exchange2元素位置效率更高
                                - 3次
                                - 链表need
                                    - 分别找前驱
                                    - 第4位 断链
                                    - 插入第2位之后
                - any时间 存/取结构 相同
                - 顺序表中：
                    - 第 i+1个数据元素 存储结构 & 第i个..
                        - $LOC(a_{i+1})=LOC(a_i)+c$
                            - ↑LOC取地址function
                    - 由$a_1$推算$a_i$
                        - $LOC(a_i)=LOC(a_1)+{i-1}*c$
                        - ![IMG_20250924_185839](https://bluejedis.github.io/picx-images-hosting/ds/IMG_20250924_185839.32ibz3h2yk.jpg)
        - --
    - operation
        - 获得GetElem
            - >将i-1下标的值 返回
                - status
                    - ↑函数
                        - 值is 结果的状态代码
                            - `*e=L.data[i-1];`
                                - 改为*e=L->data[i-1]
                                - 返回 真正的数据值
                            - `return OK;`
        - 插入ListInsert
            - >将要变的初始化为指针
                - status ListInsert(*L,int i,e)
            - step：
                - 排除error
                    - 表满
                        - if (L->length=MAXSIZE)
                    - 下标i，＜第一位置，＞最后位置
                        - if (i＜1 || i＞L→Length+1)
                - 移动
                    - 要插入位置后的元素 all后移
                    - 从后往前
                        - for (k=L->lengtha-1;k>=i-1;k--)
                            - L->data[k+1]=L->data[k]
                - 插入
                    - 在空出位置插入
                        - L->data[i-1]=e
                    - 总长+1
                        - L->length++
        - 删除ListDelet
            - step
                - 排除error
                    - 表为空
                        - if (L->length==0)
                    - ＜第一，＞最后
                - 取出要删除元素
                    - *e=L->data[i-1];
                - 移动
                    - 从前往后
                        - for(k=i;k<=L->length;k++)
                        - L->data[k-1]=L->data[k];
                - (总长-1
                    - L->length--
            ---
        - insert和dalete的复杂度
            - 最好$\Omicron (0)$
            - 最坏$\Omicron(n)$
                - $n-i+1$?怎么来的
            - 平均$\frac{n-1}{2}$
                - 第i个位置, 都需要移动n-i
        - 优缺点
            - 优
                - 无需额外存储space
            - 缺
                - 移动大量元素
- --
- 链表
    - base
        - >结点间：可连续,可不
            - 结点内必须
        - element
            - node
                - 数据域
                - 指针域 (store后继info
                    - info: 指针/链
            - 头node
                - store头指针
                    - >指向第一个node存储位置
                    - 头指针一定不为空;
                        - 头结点非必须
                        - ![Screenshot_2025-09-25-09-31-18-407_com](https://bluejedis.github.io/picx-images-hosting/ds/Screenshot_2025-09-25-09-31-18-407_com.microsoft.emmx.canary-edit.6m49prs8l7.jpg)
                    - ![Screenshot_2025-09-25-09-31-48-774_com](https://bluejedis.github.io/picx-images-hosting/ds/Screenshot_2025-09-25-09-31-48-774_com.microsoft.emmx.canary-edit.54y4o0o3t1.jpg)
        - 存储结构code
            - 单
                - ![Screenshot_2025-09-25-09-37-19-656_com](https://bluejedis.github.io/picx-images-hosting/ds/Screenshot_2025-09-25-09-37-19-656_com.microsoft.emmx.canary-edit.26lukilnwe.jpg)
                - 
        ---
    -  type
        - 单
            - define
                - type
                    - 带头node
                        - >方便**运算**实现
                        - 判空
                            - `head->next==null`
                                - next域..
                    - 不带..
                        - 判空
                            - `head==null`
                                - head直接指向1st 元素node
                - code
            - operation
                - element
                    - 判空
                    - 插入
                        - 长度为n的接在m后
                            - $O(m)$
                                - (n与m内部 本就有序
                    - 删除
                        - delet 尾pointer
                            - >复杂度与表长有关
                                - need从头find其前驱
                - 整表
                    - 创建
                        - type
                            - 头插
                                - >数组a后面'elements, 插入到链表L最前端
                                    - 2者 次序相反
                            - 尾插
                        - 复杂度
                            - worst
                                - 先establish链表，再排序
                                    - $O(n^2)$
                                        - 每个element每次都need遍历 sum存储空间
                            -  best
                                - 先排序，再链表
                                    - $O(nlog_2n)$
                                        - if-else取分支上最大
                                            - 数组排序best$O(nlog_2n)$
                                            - 建表$O(n)$
                    - 删除
            - --
        - 双
            - >2个指针
                - element
                    - prior：point to直接前驱
                    - next: ..后继
                - 前后node访问更灵活
            - operation
                - 插入
                - 删除
                    - >保证不断链; link前后2结点
                        - p->prior->next = p->next
                            - ↑前一个node的后继=p的后继
                        - p->next->prior = p->prior
                            - ↑后..前驱 =..前驱
                    - $O(1)$
        - 循环
            - 单..
                - 带头..
                    - >last指针 point to 头结点
                        - 不存在 空指针
                        - can represent队列
                            - >表头delete; 表尾insert
                                - 复杂度皆$O(1)$
                    - 判空
                        - L->next=L
                            - 指针域 与 L的值相等
                            - or表示为
                                - head->next=head
                                    - 可能为空/1' situation
                                        - head->next->next=head
                            - 插入时判空
                                - if(p==q)
                                    - p=h
                                    - <span style="color:lightgray">p为尾,q为临时
                    - 两表相接
                        - 为$O(1)$
                            - 各自指向尾结点
                            - ↑未指明先后
                - **不带**..
                    - delete首元 复杂度$O(n)$
                        - ↑保证循环性must have **前驱**
                            - 遍历find **尾结点**
                                - ↑if有尾指针，则有前驱，process为$O(1)$
                                - <span style="color:lightgray">链栈同理</span>
            - 双..
                - 带头node..
                    - >insert/==delete尾指针== fastest
                        - 头'prior指向 表尾
                    - 判空
                        - prior、next均指向 L自己
                - 不带
                - O(1)
            - --
        - 静态
            - >数组表示
                - need 较大存储空间
                    - fixed: 一次性申请
                - still链表
                    - 查找still need按序
  ---
# 栈 队列 数组
- 栈
    - type
        - 顺序栈
            - define
            - operation
                - init
                - judge空
                - ==进==
                    - type
                        - 数组a[n]
                            - 栈顶指针top=-1
                        - ..a[1...n]
                            - ..=1
                            - ..=n+1
                            ---
                        - discern: `++x`,`x++`
                            - >谁前，先算谁
                            - `++x`
                                - >先+，再用
                            - `x++`
                                - >..用，..+
                                
                - push
                    - 依次
                        -  a,b,c,d,e f
                            - 按次序 is **从左到右**'次序
                        - a,b,c,d
                            - 以c,d开头，only 1种可能
                - 出
                    - 出栈序列数
                        - >n个元素push
                            - $\frac{1}{n+1}C_{2n}^n$
                                - $C_m^n$
                                    - =$\frac{A_m^n}{A_n^n}$
                                    - ↑去除n内部排序'影响
                    - 第几个
                        - order
                            - 1,...,n
                                - 第一个输出is n
                                    - 第i个：n-i+1
                                - ... i
                                    - 第j个：不确定
                                - p_2=3
                                    - p_1可能取的数
                                        - 排1、2、4特殊值
                                            - 令P_1=1、2、4
                                                - 皆可，则不为3即可
                        - can作 c语言标识符'序列
                            - >英文字母 or 下划线"_"

                - read栈
            - --
        - 链栈
            - define
                - >**动态分配**存储空间→usually 不会栈满
                    - ↑明显优势
            - operation
                - 插入
                    - 带头
                    - 不带..
                        - x->next=top; top=x   
                            
                -  pop
                    - 不带头
                        - >将element存于x中
                            - 先存，后换
                            - x= top->data
                            - top =top->next
            - --
        - 共享栈
            - >save存储空间，降低发生上溢'possibility
                - 上溢：
                    - 满，still入
                - 下.. :
                    - 空，...读
            - ？判断栈满
                - 初始值不同，情况不一样←25题？
                    - top1-top0=1
        - --
    - compare
        - 与 队列
            - >same存储结构
- --
- left
    - 进栈4、5、6
    - 判满25
- --
- 队列
    - >尾入，头出
        - 先进先出
    - type
        - 顺序
        - 循环
            - >解决假溢出
            - 入栈
                - front..
                - `rear=(rear+1) mod Maxsize`
                    - eg.数组[0...n]
                        - maxsize: n+1
                            - discern: A[n]
                                - 下标range: [0,n-1]
            - 队列长度
                - (rear-front+maxsize) % maxsize
                    - =(rear-front+21)%21=16
                    - ↑？(8-3+21)%21 为什么是16
                - --
            - 判
                - 空
                    - >充分非必要
                        - 队列为空时，不一定首尾 指针相等
                            - ？对的吧
                            - eg.初始时Q空
                                - 且要求第一个进入队列的元素存储在A[0]处
                                - 则初始时：front:0, rear: n-1
                    - `Q.rear=Q.front`
                        - ?"front指向队首元素的前一位置"←指针位置不影响吗？
                - 满
                    - (Q.rear+1)%maxsize=Q.front
        - --
        - 链式
            - >动态分配
                - can't由首尾指针count长度
                    - ？为什么
                - 链表type
                    - >链头as 队头
                        - suite for删除
                            - usually only修改头指针
                            - special：
                                - Q only一个元素
                                    - 队列为空
                                    - 还需rear=front
                    - best：
                        - with首 尾结点' 非循环 单链表
                            - <span style="color:lightgray">if circle，完成进队和出队后还要修改为循环</span>
                    - 最不适合：
                        - only首指针' 非循环双链表
                            - 找队尾结点需要O(n)的时间
                                - --
                                - only 首/尾 ' 循环双链表 || only尾' 循环单链表
                                    - 均可在O(1)的时间内找到队首和队尾
                                - discern
                                    - only头' 循环单
                                        - O(n) 找队尾
            - - -
            - 插入
                - rear指向x
                    - rear->next=x
                - x处于队尾，next为空
                    - x->next=NULL
                - 尾指针+"1"
                    - rear=x
        - 双端
            - >2端都可 插入删除
            - 受限..
                - 输入..
                    - >一端can插入删除，一端only删除
                - 输出..
                    - >..，..插入
                - --
            - 序列judge
                - 首尾both might出
                    - 中can't
                        - ↑**输出受限**might
                            - eg.1234
                                - 右左右左
                                - 输出：4 2 1 3
                            - skill: 抓前2个 紧邻←only 输出limit能use
                    - --
                - combine with 栈
                    - ？解题思路是什么
                        - 23
- --
- application
    - 栈
        - 括号
        - 表达式
            - 中缀→后缀
            - 栈
                - 数..
                    - eg.2unit
                        - 随时是2个
                            - ？为什么04的其他，栈深是3
                    - 注意题中描述顺序
                - 符号..
                    - 弹出situation：
                        - 括号匹配
                        - 优先级更低' 入栈
                            - 弹出更高
                                - "/"高于±
                                
        - --
        - 递归
            - >usually递归 效率 更低 compared to非递归
            - 多层嵌套 一层一层代入
                - 具体的计算过程？05
                - 
        - more
            - as存储结构
                - 调用/执行函数 have局部变量
        - - -
    - 队列
        - os
            - 缓冲区
                - >先进先出
                - 
        - (层序)遍历
            - eg.图' 广度优先遍历
        - --
        - 类双端队列
            - 输出受限
                - 轨道is依次入 
                    - not分组
- --
- 数组
    - 数组
    - ==压缩存储==of 特殊matrix
        - >have分布规律' 相同/零 element
        - 压缩存储
            - >**相同**element only 分配**一个**存储空间
                - save存储空间
                    - 特殊matrix include many 零/same元素
            ---
        -  type
            - >一维数组N/B**下标**范围，default从0开始
                - need **-1**
            - n阶**对称**矩阵
                - >regarded as上/下三角
                - 顺序表
                    - $\frac{n(n+1)}{2}$
                        - $n+(n-1)+(n-2)+...+1$
                - 按行
                    - A[][]→B[]
                        - 存储地址
                            - >0行/列，总数need +1
                                - A[8][5]**起始**地址(i 0~8,j0~9
                                    - 共9行，10列
                                    - (8*10+5)*元素长度
                                        - ↑起始是算前一个末尾
                                    - --
                                - 由A[1][1],A[3][3]算A[5][5]
                                    - 先由A[3][1]算列数
                                        - 再加到A[5][1]
                        - --
                        - 下标
                            - >先看按上/下 which store
                                - 再看所求元素，是否符合
                                    - 否→ 对称转换
                                        - eg.$m_{7,2}$
                            -  第i+1行
                                - >A与B皆从0开始
                                - 先算A个数
                                    - list个数 <span style="color:lightgray">←不要和下标搞混</span>
                                - 再在B中-1
                           
                - 按列优先
                    - >以j为准
                    - A[][]→B[]
                        - 上△
                            - 前有j-1列
                                - 1+...+j-1
                            - +i
                        - 下..
                            - >抓对角线 j即i
                                - 前j-1列
                                    - $n+...+n-(j-1)+1$
                                - 第j列
                                    - $i-j+1$
                                - ![IMG_20250930_184552](https://bluejedis.github.io/picx-images-hosting/ds/IMG_20250930_184552.4ubb2k7938.jpg)
                - --
            - 三角
            - 三对角
                - >注意隐藏hint
                    - B[1...3n-2]
                        - ↑<<n(n+1)/2+1
                        - 2+3(n-2)+2=3n-2
                    - k
                        - 按行优先
                            - >2i+j-2 ←存储一维数组 起始为1
                                - 2i+j-3 ←..0
                                - 前i-1行
                                    - 2+3(i-1 -1)=3i-4
                                - 第i行'行内位置
                                    - j-i+2
                            - if have具体num
                                - >起始为0
                                    - need 最后-1
                        
                - --
            - 稀疏
                - 非零元个数 较少
                    - not 总元素
                - 压缩
                    - lose 随机存储特性
                    - 存储结构
                        - 三元组表
                            - 三元组
                                - store非零element
                                - ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b0c42fe0d8732a593781e47414cea74094d463474100aa7492a58b47b74fc271.jpg)  
                            - also need
                                - M'行列数
                                - ↑才知M大小
                        - 十字链表
                    
              



# (字符)串
>0个/多个 字符组成的有限序列
- concept
    - base
        - 比大小
            - 2个串不等时
                - 前k-1位，=
                - 比较k位' ASCII码
    - 存储
        - type
            - 定长顺序
                - >连续存储单元
                    - 存储区length：固定
            - 堆
                - >连续存储单元
                    - 动态分配
            - 块链
                - >链表
                    - 结点称为块
    - 操作
        - >more关注：子串
        - list：
        - 最小操作子集
            - <span style="color:lightgray">5</span>
                - str
                    - Assign
                    - Compare
                    - Length
                - Contact
                - SubString
- --
- 模式匹配
    - >子串的定位
    - 简单..
        - >定长顺序存储
            - 暴力match：2个串：主串S 和 模式串T
        - step
            - 从1st 字符 开始比较
                - if ==
                    - 继续逐字
                - else
                    - 2rd开始
            - return
                - 序号 of T在S中的 首字符 
                    - ↑成功
                - 0
                    - ↑失败

        - --
    - KMP
        - base
            - >analyze 模式串T structure<span style="color:lightgray">←部分匹配值PMV</span>
                - utilize已匹配prefix 滑动<span style="color:lightgray">← 已知后面elements have相等/匹配过</span>
                - 主串指针 不用回退
                    - ↑指针值不用变小
            - --
            - step
                - >移动位数=已匹配symbol数 - PMV
                    - ==PMV==:
                        - 部分匹配值
                            - >取 最长match'**长度**
                                - ![IMG_20250930_194051](https://bluejedis.github.io/picx-images-hosting/ds/IMG_20250930_194051.wixlxv8qb.jpg)
                            - 前缀∩后缀
                                - >从→/← 依位次划线（3位及以上，余1位）
                                - ![IMG_20250930_191402](https://bluejedis.github.io/picx-images-hosting/ds/IMG_20250930_191402.83aez8v3lm.jpg)
            - --
            - ==next数组==
                - >j=next[j]
                    - 与i无关
                - >PM表右移一位
                    - 首位 填充-1
                        - 舍origin最后一位
                    - (整体+1)
                        - ↑ 不一定
                - detail
                    - 
            ---
        - 优化
            - >递归
        - --
        - 时间复杂度
            - 简单
                - O(mn)
            - KMP
                - O(m+n)
---
left 
- nextval（09）
    - 具体process再想一下 
    - 10~11
---
# 图
- concept
    - base type
        - 图
            - 向
                - 有向
                    - >弧=边
                - 无向
                    - >无方向性
                        - every边，对于一个顶点，既as入度also出度
                            - ∴ 无向图中 入度=出度 

                - --
            - **完全**
                - 无向完全图
                    - >∀ 2vertex have边
                    - $\frac{n(n-1)}{2}$
                - 有向完全graph
                    - >2方向相反'弧 in any 2 vertex
                        - 一定 强连通graph
                            - 各vertex 有path
                                - 不一定有 弧/边<span style="color:lightgray"> (←不一定相邻
                    - $n(n-1)$
            - 子图
                - not any V、E子集 all can构成子集
                    - eg.顶点of E子集中的关联边 
                        - 不在V子集中
        - **连通**
            - 连通
                - >any顶点间 have **path**存在
                    - not 边
                        - ↑与 "完全" 区分开
                            - "通"is路
                            - "完全"is"弧"
                - 连通
                    - >无向图
                        - 边
                            - 至少
                                - 树: n-1
                                - ![IMG_20251001_162542](https://bluejedis.github.io/picx-images-hosting/ds/IMG_20251001_162542.41yfm46dlc.jpg)
                            - 确保
                                - n-1个顶点(**完全**)+1边(link独立vertex
                                    - eg.6vertex
                                        - $\frac{5(5-1)}{2}$ +1边
                - 非连通
                    - 无向图
                        - 已知边 求vertex
                            - 1**完全**无向图+独立顶点
                            - eg.28边
                                - E全部来自 完全无向图
                                - $\frac{n(n-1)}{2}=28$
                                    - 再+1顶点
            - 强连通
                - >有向图
                - 边至少
                    - 环：n
                    - ![IMG_20251001_162505](https://bluejedis.github.io/picx-images-hosting/ds/IMG_20251001_162505.1vz10cevs0.jpg)
            - --
            - (强)连通**分量**
                - >极max
                - count:
                    - >可以有多个
                    - 连通中 取极大
                    - 独立顶点(or only入/出度)单独as 分量
                        - <span style="color:lightgray">↑understand，就自身而言，已是极大</span>
                        - eg.无向
                            - [见下](#section1)
                        - eg.有向
                            - ![image](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/image.5fkyq7gjo8.png)
                            - 连通中 找极大
                                - ACDE
                            - 非连通 顶点单独as
                                - B
            - --
        - 生成<span style="color:lightgreen">树</span>
            - 无回路
            - >极min**连通**子图 ←边数least
                - n个顶点
                    - n-1条边
                        - ∴n个顶点，n条边，must 环
                            - ↑n个顶点，n条边
                                - n课生成树<span style="color:lightgray">(举特例4</span>
                        - discern：
                            - 连通图G n个顶点
                                - 子图: n个顶点 n-1条边
                                    - 不一定is生成树
                                        - ↑1个孤立点 n-1顶点和n-1边构成回路
                                        - <span style="color:lightgray">↑n个顶点，若为完全图，有\frac{n(n-1)}{2}条边</span>
                - 无环子图
                    - $V'=V$
                    - --
                - discern：
                    - 连通分量
                        - **极max**连通子图 ←顶点边数 as many as possible
                            - 连通图 即itself
                                - 非.. 找极大
                                    <a id="section1"></a>
                                    - eg.51个v，21 E，连通分量最多为
                                        - >是极值不是最值
                                        - 21边对应v 构成完全图
                                            - $\frac{6*7}{2}$
                                            - 7顶点
                                        - 剩下51-7=44个顶点 对应44个连通分量
                                    - --
                                    - 生成森林
                                        - >consist of 连通分量 in 连通树
                                        - count
                                            - 森林中的树
                                                - >key：边数+1=顶点树
                                                    - ∴ 连接各树根结点as一棵树
                                                - n个顶点，e条边
                                                    - 设树 数量x
                                                    - e+(x-1)+1=n
                                            
        - element
            - 度
                - 无向graph
                    - >边的条数of vertex 对应的
                        - 和 of all vertex度or边数=2*vertex数
                            - ↑∴所有顶点的度之和为偶数
                - 有向
                    - 入度
                    - 出度
                    - sum
                        - 一个vertex' Max度
                            - $2n-2$
                            - ![IMG_20251001_163704](https://bluejedis.github.io/picx-images-hosting/ds/IMG_20251001_163704.70appmt18d.jpg)
            - 路径
                - 由**顶点**和相邻顶点序偶  构成的**边**所形成的**序列**
                - 简单path
                    - vertex不重复
                    - ↑回路 not
            - 有向tree
            - --
        - 抽象的情况，任何时候举特例
            - A B C
                - 树or环
- --
- store(2 2
    - base
        - 邻接矩阵
            - type
                - 无向
                    - >对称
                - 有向
                    - 度
                        - 入度看列
                            - $v_i$
                                - $\Sigma_{j=1}^nA[j][i]$
                                    - special
                                        - 有向带权graph
                                            - 第i列非∞且非0'元素**个数**←对角线常用0表示
                                            - ![image](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/image.1apde5rg1z.png)
                                - discern：
                                    - 无向graph' 度
                                        - >对称matrix
                                            - 第i行/列
                                        - $\Sigma_{j=1}^nA[j][i]/A[i][j]$
                        - 出度看行
                            - count弧，直接按行看出度
                                -![ ](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/IMG_20251001_183638.1ovt51nc24.webp)
                        - ∴sum
                            - first judge whether对称
                                - ![ ](https://bluejedis.github.io/picx-images-hosting/DS/IMG_20251001_191235.83af0ob432.jpg)
                            - N
                                - 列表
                                - ![ ](https://bluejedis.github.io/picx-images-hosting/DS/IMG_20251001_191357.77dxl81q6v.webp)
            - $A^n$
                - >长度为n的路径数目
                - eg.$A^2$中的某元素$a^2_{i,j}=3$
                    - 存在 3条 长度=2的路径 (from i to j
            - unique
                - 主对角线上元素all0, others 1
                    - 各vertex 皆有边相连
                    - ↑完全图
            - space
                - only V有关
        - --
        - 邻接表法
            - >表示不唯一
            - element
                - >顶点表结点，边表结点
                - 边表结点
                    - 无向
                        - >边表结点数必 偶
                            - every边 store2次
                                - ∴ max边表结点:$n(n-1)$
                                    - ↑边数$\frac{n(n-1)}{2}$
                            - 度
                                - v_i(具体一vertex)
                                    - 即为第i个链表的 node数
                        - 复杂度
                            - 空间：
                                - $O(|V|+2|E|)$
                                    - ↑时间复杂度ignore系数$O(|V|+|E|)$
                    - 有向
                        - >充分：边表结点数为奇
                        - 度
                            - 入度
                                - 顶点v在**边表**中出现的次数
                                    - need遍历all
                                        - $O(|V|+|E|)$
                            - **出度**
                                - 顶点表node 对应的边表结点
                                    - $O(V)$
                            - ∴计算顶点总度/删除整边
                                - need遍历all $O(|V|+|E|)$
            - space
                - 与V、E有关
    - add
        - >
        - 十字链表
            - >有向
        - 邻接多重表
            - >无向
- base operation
- --
- 遍历(2
    - >每个node只能被visit一次
    - type
        - 广度优先BFS
            - >二叉树' 层序遍历
            - base：
                - 辅助data结构
                    - queue
                        - vertex最多 入队once
                - 作用
                    - >无权graph 最短路径
                        - ∴BFS生成树≤DFS..
            - 复杂度
                - 邻接matrix: 
                    - 时间: $O(n^2)$
                - 邻接表:
                    - 时间:$O(n+e)$
                    - 空间: $O(n)$
        - 深度..DFS
            - >树' 先序
            - base
                - 序列
                    - >不唯一
                        - <span style="color:lightgray">由边对draw graph 最稳妥</span>
                    - need标志位
                        - 非回路，also有可能visit多次
                            - ![IMG_20251002_192150](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/IMG_20251002_192150.2328xdrln8.webp)
                                - --
                            - 非强连通
                                - also might一次访问完
                                    - ![IMG_20251002_192202](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/IMG_20251002_192202.70apr85dec.webp)
                - 向
                    - 非连通无向graph
                        - DFS/BFS调用数
                            - = 连通分量数
                        - - -
                    -  judge whether have回路
                        - type
                            - 无向
                                - 
                            - 有向
                                - ？left: 具体是什么逻辑(12题
                - - -
                - step
                    - 
                    - eg.
                        - need 按栈退回
                        - ![IMG_20251002_194448](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/IMG_20251002_194448.3uv7sb4d7k.webp)
                        - 3：
                            - 按栈退回
                            - ∴ 先b , 而不能先c
            - 复杂度
                - ..matrix:...
                - 邻接表：..

    - 
- --
- apply(2 2
    - 最小生成树 MST (2
        - >带权无向连通
        - >按边的权值 衡量排序
        - base
            - 向
                - 无向连通
                    - any 无向连通'MST
                        - 1 or 多
                    - **唯一**性
                        - 权值
                            - 无 权same'边 ←充要
                            - MST唯一
                            - discern：
                                - have same
                                    - 也可能唯一 (不一定不唯一
                                    - <span style="color:lightgray">↑无向图 itself is 树</span>
                            - --
                        - 总**边数**
                            - = n-1 ← MST唯一
                                - discern:
                                    - "n个顶点，选n-1条边"←not总数
                            - ＜.. ← 无
                            - ＞.. ← 多个/不唯一
                                - 一定有权值same的边
                                    - <span style="color:lightgray">不一定min</span>
                        - --
                    - MST权值
                        - 不一定is 未选边中 smallest
                            - ↑smallest might 不连通
                                - ![IMG_20251002_154006](https://bluejedis.github.io/picx-images-hosting/DS/IMG_20251002_154006.8admxbpkm1.webp)
                                - 同时避免形成环
            - p、k
                - get' MST
                    - 可能same 也可能不
                        - >代价must 相等
                - 选边
                    - p按顶点
                        - 不同vertex 开始，get的MST不一定same
                    - k avoid回路
                - --
                - MST不能cover 最短路径
        - type
            - prim
                - >局部 min ←当前v adjacent
                    - <span style="color:lightgray">与树T中 vertex 最近</span>
                    - >key:抓出度、连通 till所有vertex
                        - 无回路
                            - step
                                - 一条到头，return shortest(T中最近) to 剩余vertex
                                    - 重新走
                                    - eg.![IMG_20251002_161848](https://bluejedis.github.io/picx-images-hosting/DS/IMG_20251002_161848.lw3vg3c9f.webp)
                    -  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/413704bf3253c2671855c3395ee5f1027e23761bf8da66bca7df35e4ef0ebc82.jpg)  
            ---
            -  k
                - >整体中 min
                    - ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfb9edf9b314446b65731e53e39a987ef76f3a653992a0d176bd51f77fe01337.jpg)  
    - - 
    - 最短path(3
        - >一定is 简单path
        - >带权 (有/无 向)图
            - discern：
                - **BFS** only 无权graph
                    - ↑权值=1 即无权
        - Dij
            - >1→others 最短**path**
                - dist[]：记录从源点到各顶点当前最短路径长度
                    - 初始值：
                        - 有弧时为弧上权值
                        - 无弧时置为∞
            - step：
                - 选出到各vertex' path 中 最短'path(V-S
                    - `dist[j] = Min{dist[i]|vi∈V-S}`
                    - ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f8939ca7029cd3a8d7e5c73314b7488664116e02a550898bfbcd99d295b6878.jpg)  
                    - ![IMG_20251002_095124](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/IMG_20251002_095124.2a5gs8zztk.webp)
                    - attention：next应该是 距离S集合整体vertex中 最近的
                        - 一次更新多个距离info
                        - eg.前2次更新
                            - ![image](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/image.b9a2f43wt.webp)
                            - ![image](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/image.96a4cxtzrt.webp)
                - 更新vertex集合S
                    - till all vertex都在S中
            - lack
                - 不适用于 **负权**值
                    - recorded路径need 更新
                        - but can't
                - also suite
                    - 带权回路
                    - ∀2 vertex间
                        - $O(v^3)$
            ---
        -  flo
            - >∀ 2vertex 间 path
                - use邻接矩阵
            - step
                - >逐步加入 k个中间点
                    - 更短，则**替换**
                        - <span style="color:lightgray">↑此时，$path_{k-1}$不再是$path_{k}$子集</span>
                    - $A^{(k)}$
                        - $k$ : 绕行 **第** $k$ 个顶点的运算步骤
                        - discern：
                            - $A^n$
                - 逐个更新矩阵
                    - >focus出度
                - --
            - lack
                - 带负权回路
                
        - --
    - >有向
    - topology排序
        - >AOV网
            - 用有向无环图DAG express一个工程
                - DAG
                    - 描述表达式
                        - 转换为二叉树--去除重复vertex→有向无环图
                            - eg.(x+y)((x+y)/x)
                                - ?这个是中缀直接写
                                    - (x+y)*((x+y)/x)
                                        - ![image](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/image.1ovt6fq4j9.webp)
        - step
            - 循环：
                - 入度=0' 结点u
                    - 输出
                    - &删除边
                - 新的=0 v结点 as u
                - till AOV网 为空
                    - 非空，则exist回路
                        - ↑强连通 必有环，故不能topology
                            - ↑include 顶点数＞1' 强连通分量
        - 序列
            - 个数
                - list 集合分支, then sum
                    - >始终抓 out条件: 度=0
            - **有序**
                - **邻接matrix** 必 三角
                    - ↑三角matrix 必 no环
                        - ∴三角matrix 一定有topology
                            - 不一定唯一
                                - (可以后续有分支
                                - eg.![IMG_20251002_162324](https://bluejedis.github.io/picx-images-hosting/DS/IMG_20251002_162324.9o061elk2m.webp)
                    - discern；
                        - 去掉有序
                            - 则 一般matrix？ why(19题
            - 唯一
                - can't唯一 ensure 图
                    - eg. topology皆v1、v2、v3、v4
                        - ![IMG_20251002_152911](https://bluejedis.github.io/picx-images-hosting/DS/IMG_20251002_152911.wixojqt4k.webp)p
        - type：
            - 逆拓扑排序
                - >choose 出度=0
                    - delete其入度
                - =DFS退栈 return相应顶点
    - 关键path
        - >AOE网
            - **带权**DAG
        - definition：
            - 源点→汇点 **MAX**路径**长度**的路径
                - 源/汇点
                    - only one 入/出度=0 '开始/结束 点
        - count
            - 关键路径
                - 长度
                    - >即 最长path
                    - 缩短
                        - 缩短**all** 关键path 上 共有的1个 any 活动 ← or all path活动 同时short
                            - ↑活动延迟，工期也延长
                    - 改变
                        - 改变....共有
                            - 不一定产生 不同关键路径
                                - ↑缩短might，延长一定不会
            -  时间
                - 最早
                    - 该事件 正向topology
                - 最迟
                    - 逆向..
                - 余量
                    - vl(后vertex)-ve(前vertex)-weight
                    - 关键活动
                        - 余量=0
            - --
            - "活动"由 顶点/事件 算其cost
                - 顶点/事件
                    - 最早ve
                        - max(源点→该vertex)
                    - 最迟vl
                        - $关键路径L-max(汇点→该vertex)$
                - ==活动==
                    - 最早
                        - =ve(前vertex)
                            - eg.活动d 最早：max{a,c+b}
                    - 最迟
                        - =vl(后vertex)- weight(itself)
                            - eg.  活动d最迟：length-g-d
                                - ![IMG_20251002_175044](https://bluejedis.github.io/picx-images-hosting/DS/IMG_20251002_175044.6wr3tf2ehx.webp)
                        - --
                    - 余量
                        - >list顶点' 最早/迟
                            - vl(后vertex)-ve(前vertex)- weight(itself)
                        - eg.
                            - ![image](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/image.9o061jsvsj.webp)
                            - ![image](https://github.com/bluejedis/picx-images-hosting/raw/master/DS/image.9gwy646dey.webp)
                    
- --
- 结构体中->和.操作的区别
    - 变量本身use"."
    - 指针use"->"

- 注意表述是 局部or整体
    - 线性表include 顺序&链式

- left 
    - 双链表
        - 插入、删除：15、16、17 ？35具体过程✓ ←整理一下不变的
            - p后的结点q
            - p指向的结点
            - p后插入指针s的结点
                - ？?s->prev = s->next->prev
        - 33题想考什么？
            - 如何理解逻辑位 和 连接地址？
