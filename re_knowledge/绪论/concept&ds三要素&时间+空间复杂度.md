<div style="float: left; width: 64%; padding: 1%;">

## 【知识框架】

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/07b4046e520345a2f48d4734855c101b74d5ea80544a0b7500411d020f367de0.jpg)

</ul>

## 【复习提示】

<ul>

- not in 大纲
- 初步了解数据结构的基本内容和基本方法
- 分析算法的**时间**复杂度和**空间**复杂度是本章重点，need熟练掌握
  - 算法设计题: 分析时间复杂度、空间复杂度
  - 时间复杂度' 选择题

</ul>

# 基本概念和术语

<ul>

## 数据

<ul>

- 信息的**载体**
- 是描述客观事物属性的以下内容的**集合**：
  - **数**
  - **字符**
  - 所有能输入到计算机中并被计算机程序识别和处理的**符号**
- 数据是计算机程序加工的原料

</ul>

## 数据元素

<ul>

- 数据的基本单位
- 通常作为一个整体进行考虑和处理
- 组成结构：
  - 可由若干数据项组成
  - 数据项是构成数据元素的不可分割的最小单位
  - 例如：学生记录是一个数据元素
    - 由学号、姓名、性别等数据项组成

</ul>

## 数据对象

<ul>

- 具有相同性质的数据元素的**集合**
- 数据的一个子集
- 示例：
  - 整数数据对象是集合 $N=\{0,\pm1,\pm2,\cdots\}$

</ul>

## 数据类型

<ul>

- 是一个值的集合和定义在此集合上的一组操作的总称

### 原子类型

<ul>

- 其值不可再分的数据类型

</ul>

### 结构类型

<ul>

- 其值可以再分解为若干成分（分量）的数据类型

</ul>

### 抽象数据类型

<ul>

- 一个数学模型及定义在该数学模型上的一组操作
- 特点：
  - 通常是对数据的某种抽象
  - 定义了数据的取值范围及其结构形式
  - 定义了对数据操作的集合

</ul>

</ul>

## 数据结构

<ul>

- 是相互之间存在一种或多种特定关系的数据元素的集合
- 数据元素关系：
  - 不是孤立存在的
  - 它们之间存在某种关系
  - 这种数据元素相互之间的关系称为结构（Structure）

### 数据结构的三个方面

<ul>

- 逻辑结构
- 存储结构
- 数据的运算

</ul>

### 结构关系

<ul>

- 数据的逻辑结构和存储结构是密不可分的两个方面
- 算法相关：
  - 算法的设计取决于所选定的逻辑结构
  - 算法的实现依赖于所采用的存储结构

</ul>

</ul>

# ds三要素

<ul>

## data'逻辑结构

<ul>

### 定义与分类

<ul>

- 逻辑结构是指 <u>数据元素</u> 之间的逻辑关系
  - 从逻辑关系上描述数据
  - 与数据的存储无关
  - 独立于计算机

</ul>

### 主要分类

<ul>

- 线性结构
  - 线性表为典型
- 非线性结构
  - 集合、树和图为典型

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4c0160e3de7b882cb02760de400a3f1d14a69d82805811692110d7243ef0d6d6.jpg)
图1.1数据的逻辑结构分类图

</ul>

### 基本结构关系类型

<ul>

#### 集合结构

<ul>

- 数据元素之间除"同属一个集合"外，别无其他关系

</ul>

#### 线性结构

<ul>

- 数据元素之间只存在一对一的关系

</ul>

#### 树形结构

<ul>

- 数据元素之间存在一对多的关系

</ul>

#### 图状/网状结构

<ul>

- 数据元素之间存在多对多的关系

</ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3d4eee36de9ffedeebe77662203b1d9d8c21ec8508de8057cb03357e0b73365f.jpg)
图1.2四类基本结构关系示例图

</ul>

</ul>

## data'存储结构

<ul>

### 基本概念

<ul>

- 存储结构是数据结构在计算机中的表示（物理结构）
  - 包括数据元素的表示和关系的表示
  - 是用计算机语言实现的逻辑结构
  - 依赖于计算机语言

</ul>

### 主要存储方式

<ul>

#### 顺序存储

<ul>

- 特点：
  - 逻辑相邻元素物理位置也相邻
  - 关系由存储单元邻接关系体现
- 优点：
  - 可实现随机存取
  - 每个元素占用最少存储空间
- 缺点：
  - 只能使用相邻存储单元
  - 可能产生较多外部碎片

</ul>

#### 链式存储

<ul>

- 特点：
  - 逻辑相邻元素物理位置不必相邻
  - 通过指针表示元素间逻辑关系
- 优点：
  - 不会出现碎片现象
  - 能充分利用所有存储单元
- 缺点：
  - 需额外指针存储空间
  - 只能实现顺序存取

</ul>

#### 索引存储

<ul>

- 特点：
  - 建立附加索引表
  - 索引项形式：（关键字，地址）
- 优点：
  - 检索速度快
- 缺点：
  - 索引表占用额外存储空间
  - 增删数据需修改索引表，耗时多

</ul>

#### 散列存储

<ul>

- 特点：
  - 根据关键字直接计算存储地址
  - 也称哈希（Hash）存储
- 优点：
  - 检索、增删操作快
- 缺点：
  - 散列函数不好可能造成冲突
  - 解决冲突增加时空开销

</ul>

</ul>

</ul>

## data'运算

<ul>

### 运算组成

<ul>

- 包括运算的定义和实现
  - 定义针对逻辑结构
    - 指出运算的功能
  - 实现针对存储结构
    - 指出运算的具体操作步骤

</ul>

</ul>

# 算法和算法评价

<ul>

## 基本概念

<ul>

### 算法定义

<ul>

- 算法（Algorithm）是对特定问题**求解步骤**的一种描述
  - 是指令的有限序列
  - 每条指令表示一个或多个操作

</ul>

### 算法特性

<ul>

- 一个算法具有五个重要特性：
  - 有穷性
    - 一个算法必须总在执行有穷步之后结束
    - 且每一步都可在有穷时间内完成
  - 确定性
    - 算法中每条指令必须有确切的含义
    - 对于相同的输入只能得出相同的输出
  - 可行性
    - 算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现
  - 输入
    - 一个算法有零个或多个输入
    - 这些输入取自于某个特定的对象的集合
  - 输出
    - 一个算法有一个或多个输出
    - 这些输出是&输入有着某种特定关系的量

</ul>

### 算法设计目标

<ul>

- 设计一个"好"的算法应考虑达到以下目标：
  - 正确性
    - 正确地解决求解问题
  - 可读性
    - 良好的可读性
  - 健壮性
    - 对输入的**非法**数据做出反应或**处理**
  - 高efficiency&低存储量需求
    - efficiency：算法执行的时间
    - 存储量需求：算法执行过程中所need的最大存储空间
    - both与问题的规模有关

</ul>

</ul>

## 算法efficiency的度量

<ul>

> pro：（算法题）分析时空复杂度（2010一2013、2015、2016、2018一2021）

- 算法efficiency的度量 is described through **时间**复杂度和**空间**复杂度

### 时间复杂度

<ul>

> pro：分析算法的时间复杂度（2011一2014、2017、2019、2022）

#### 基本概念

<ul>

- 频度
  - 一个语句的**频度** ← 该语句在算法中被重复执行的**次数**
  - 算法中所有语句的频度之和记为 $T(n)$
    - 是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$ 的数量级
    - 基本运算（最深层循环中的语句）的频度与 $T(n)$ 同数量级
      - thus, usually将算法中**基本运算**的执行次数的数量级as该算法的时间复杂度

</ul>

#### 时间复杂度表示

<ul>

- 算法的时间复杂度记为 $T(n)=O(f(n))$
  - $O$ 的含义是 $T(n)$ 的数量级
    - 严格的数学定义是：
      - 若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数
        - 则存在正常数 $C$ 和 $n_{0}$
        - 使得当 $n{\geqslant}n_{0}$ 时
      - 都满足 $0\leqslant T(n)\leqslant C f(n)$

</ul>

#### 影响因素

<ul>

- 算法的T复杂度not only依赖于问题的**规模** $n$
- but also取决于待输入数据的**性质**（如输入数据元素的初始状态)

eg，在数组 $\mathbb{A}\left[0...\mathtt{n}-1\right]$ 中，查找给定值 $k$ 的算法大致如下：
(1)  $\scriptstyle{\dot{\mathbf{i}}}=\mathbf{n}-1$  (2)while(  $\scriptstyle{\dot{\mathbf{1}}}>=0\,\&$  &(A[i]  $!\!=\!\!\kappa$  (3)  $\mathrm{i--}$  （4)returni;

该算法中语句3（基本运算）的频度不仅&问题规模 $n$ 有关，而且&下列因素有关：
- $\textcircled{\scriptsize{1}}$ 若A中没有& $\kappa$ 相等的元素，则语句3的频度 $f(n)\!=\!n$
- $\circledcirc$ 若A的最后一个元素等于k，则语句3的频度 $f(n)$ 是常数0

</ul>

#### 时间复杂度分类

<ul>

- 最坏时间复杂度
  - 在最坏情况下，算法的时间复杂度
- 平均时间复杂度
  - 所有可能输入实例在等概率出现的情况下，算法的期望运行时间
- 最好时间复杂度
  - 在最好情况下，算法的时间复杂度
- 一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长

</ul>

#### 时间复杂度计算规则

<ul>

- TIME COMPLEXITY两条规则：
  - 1）加法规则：
    $T(n)=T_{1}(n)+T_{2}(n)=O(f(n))+O(g(n))=O(\operatorname*{max}(f(n),g(n)))$
  - 2）乘法规则：
    $T(n)=T_{1}(n)\times T_{2}(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$

eg，设a{）、b{}、c{}三个语句块的时间复杂度分别为 $O(1)$、$O(n)$、$O(n^{2})$，则
-  #ac() /时间复杂度为 $O(n^{2})$，满足加法规则
- al bi）/时间复杂度为 $O(n^{3})$，满足乘法规则

</ul>

#### 常见时间复杂度

<ul>

- 常见的渐近时间复杂度
  $O(1)<O(\log_{2}n)<O(n)<O(n\log_{2}n)<O(n^{2})<O(n^{3})<O(2^{n})<O(n!)<O(n^{n})$

</ul>

</ul>

### 空间复杂度

<ul>

#### 基本概念

<ul>

- 算法的空间复杂度 $S(n)$ 定义为该算法所需的**存储空间**
  - 是问题规模 $n$ 的**函数**
  - 记为: $S(n)=O(g(n))$

</ul>

#### 空间需求分析

<ul>

- 程序执行时需要的存储空间：
  - 本身所用的指令、常数、变量和输入数据
  - 对数据进行操作的工作单元
  - 存储一些为实现计算所需信息的**辅助**空间

</ul>

#### 空间复杂度计算

<ul>

- 若输入数据occupy空间only取决于问题本身，和算法无关
  - only need分析除输入和程序之外的额外空间
- eg，若算法中新建了几个输入数据规模 $\bf{n}$ 相同的辅助数组 → 空间复杂度为 $\bf{O(n)}$

</ul>

#### 原地工作算法

<ul>

- 算法原地工作：
  - 算法所需的辅助空间为常量，即 $O(1)$

</ul>

</ul>

</ul>

</ul>

# 归纳总结

<ul>

## 重点：分析程序的时间复杂度。

<ul>

- 一定要掌握分析时间复杂度的方法和步骤
- 很多读者在做题时一眼就能看出程序的时间复杂度，但就是无法规范地表述其推导过程

</ul>

## 题型的两种形式:

<ul>

### 1.循环主体中的变量 参与循环条件

<ul>

#### 递推实现分析方法

<ul>

- 首先找出基本运算的执行次数 $x$ &问题规模 $n$ 之间的关系式
- 解得 $x=f(n)$
- $f(n)$ 的最高次幂为 $k$
- 则算法的时间复杂度为 $O(n^{k})$

</ul>

#### 示例分析

<ul>

![image.png](https://s2.loli.net/2024/11/10/nCfwxqPOMhp2sZL.png)

##### 例1分析

<ul>

- 设基本运算 $\dot{\Sigma}\!=\!\dot{\Sigma}^{\star}2$ 的执行次数为 $t$
- 则 $2^{t}{\leqslant}n$
- 解得 $t{\leqslant}\log_{2}\!n$
- 故 $T(n)=O(\log_{2}\!n)$

</ul>

##### 例2分析

<ul>

- 设基本运算 $\scriptstyle{\mathrm{y}}={\mathrm{y}}+1$ 的执行次数为1
- 则 $t\!=\!y\!-\!5$
- 且 $(t+5+1)(t+5+1)<n$
- 解得 $t\!<\!\sqrt{n}-6$
- 即 $T(n)=O({\sqrt{n}}\,)$

</ul>

</ul>

</ul>

### 2.循环主体中的变量 与循环条件无关

<ul>

#### 分析方法

<ul>

- 数学归纳法或直接累计循环次数
- 多层循环时从内到外分析
- 忽略单步语句条件判断语句
- 只关注主体语句的执行次数

</ul>

#### 程序类型分析

<ul>

##### 递归程序

<ul>

- 一般使用公式进行递推
- 时间复杂度的分析如下：
  - $T(n)=1+T(n-1)=1+1+T(n-2)=\cdots=n-1+T(1)$
  - 即 $T(n)=O(n)$ 0

</ul>

##### 非递归程序

<ul>

- 分析比较简单
- 可以直接累计次数

</ul>

</ul>

</ul>

</ul>

</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
