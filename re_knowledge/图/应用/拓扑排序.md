<div style="float: left; width: 64%; padding: 1%;">
    
## 拓扑排序
<ul>

### AOV网的基本概念
<ul>

- AOV网定义：
  - 用有向无环图表示一个工程
  - 顶点表示活动
  - 有向边<Vi,Vj>表示活动Vi必须先于活动Vj进行

- 活动关系：
  - Vi是Vj的直接前驱
  - Vj是Vi的直接后继
  - 前驱和后继关系具有传递性
  - 活动不能以自己作为自己的前驱或后继

</ul>

### 拓扑排序的定义
<ul>

#### 基本定义
- 由有向无环图顶点组成的序列，满足：
  - 每个顶点出现且只出现一次
  - 若顶点A在序列中排在顶点B前面，则图中不存在从B到A的路径

#### 替代定义
- 对有向无环图顶点的一种排序：
  - 若存在从顶点A到顶点B的路径，则B在排序中出现在A后面
  - 每个AOV网都有一个或多个拓扑排序序列

> pro：拓扑排序和回路的关系（2011）

</ul>

### 拓扑排序算法
<ul>

#### 基本步骤
- 从AOV网中选择一个没有前驱（入度为0）的顶点并输出
- 从网中删除该顶点和所有以它为起点的有向边
- 重复上述步骤直到：
  - AOV网为空 或
  - 不存在无前驱的顶点（说明存在环）

> pro：拓扑排序的实例（2010、2014、2018、2021）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8810ace9ff20c9670d0e1272ddf371bd248455d387e1a48022dfcfc7f025d42a.jpg)

#### 算法实现

TopologicalSort(Graph G){
    InitStack(S);
    int i;
    for(i=0;i<G.vexnum;i++)
        if(indegree[i]==0)
            Push(S,i);
    int count=0;
    while(!IsEmpty(S)){
        Pop(S,i);
        print[count++]=i;
        for(p=G.vertices[i].firstarc;p;p=p->nextarc){
            v=p->adjvex;
            if(!(--indegree[v]))
                Push(S,v);
        }
    }
    if(count<G.vexnum)
        return false;
    else
        return true;
}


> pro：不同存储方式下的拓扑排序的效率（2016）

#### 时间复杂度
- 邻接表存储：O(|V|+|E|)
- 邻接矩阵存储：O(|V|²)

> pro：DFS实现拓扑排序的思想（2020）

#### DFS实现方法
- 结点关系分类：
  - u是v的祖先：v的DFS结束时间先于u
  - u是v的子孙：v的结束时间大于u
  - u和v无路径关系：拓扑序列关系任意

</ul>

### 逆拓扑排序
<ul>

#### 步骤
- 选择没有后继（出度为0）的顶点并输出
- 删除该顶点和所有以它为终点的有向边
- 重复直到AOV网为空

</ul>

### 注意事项
<ul>

#### 关键问题
- 入度为零的顶点：
  - 没有前驱活动
  - 前驱活动都已完成
  - 可以开始或继续的活动

> pro：分析给定图的拓扑序列的存在性和唯一性（2011）

#### 排序结果特性
- 非唯一性：
  - 顶点有多个直接后继时，结果通常不唯一
  - 顶点在线性序列中有唯一前驱后继关系时，结果唯一

#### 邻接矩阵特性
- 可按拓扑排序结果重新编号
- 生成新的邻接存储矩阵（可能是三角矩阵）
- 三角矩阵特性：
  - 若邻接矩阵是三角矩阵，则存在拓扑序列
  - 反之不一定成立

</ul>

</ul>   

</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
