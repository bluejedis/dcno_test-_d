<div style="float: left; width: 64%; padding: 1%;">

## 最小生成树

<ul>

### 基本概念
<ul>

- 生成树的定义
  - 包含图的所有顶点
  - 只含尽可能少的边
  - 砍去一条边会使其变成非连通图
  - 增加一条边会形成回路

</ul>

### 最小生成树定义
<ul>

- 带权连通无向图G中
  - 不同生成树权值可能不同
  - 权值之和最小的生成树称为最小生成树(MST)

</ul>

### 最小生成树性质
<ul>

> pro：最小生成树的性质（2012、2017）

#### 唯一性
- 权值相同时可能不唯一(树形不唯一)
- 权值互不相等时唯一
- 边数比顶点数少1时，G本身就是最小生成树

#### 权值特性
- 权值之和唯一且最小
- 边数为顶点数减1

#### 路径特性
> pro：最小生成树中某顶点到其他顶点是否具有最短路径的分析（2023）

> attention 

- 不能保证任意两点间路径最短
  - 如下图所示例子

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/02e492777fdd70471f99a72a7ca8d6237b0cbdc152f003539de53616c1664f55.jpg)

</ul>

### 构造算法基础
<ul>

#### 基本性质
- G=(V,E)为带权连通无向图
- U是V的非空子集
- (u,v)是最小权值边，其中u∈U，v∈V-U
- 必存在包含边(u,v)的最小生成树

#### 主要算法
- 基于贪心策略
  - Prim算法
  - Kruskal算法

</ul>

### 通用最小生成树算法
<ul>

GENERICMST(G)(
T = NULL;
while T未形成一棵生成树
    do找到一条最小代价边(u,v)并且加入T后不会产生回路
    T = T∪(u,v)

- 算法特点
  - 每次加入一条边
  - 逐渐形成生成树

</ul>

### Prim算法
<ul>

#### 算法思想
- 执行非常类似于寻找图的最短路径的Dijkstra算法（见下一节）

>pro：Prim算法构造最小生成树的实例（2015、2017、2018）  

#### 构造过程
- 初始阶段
  - 从图中任取一顶点（如顶点1）加入树T
  - 此时树中只含有一个顶点
- 生长阶段
  - 选择一个与当前T中顶点集合距离最近的顶点
  - 将该顶点和相应的边加入T
  - 每次操作后T中的顶点数和边数都增1
- 终止条件
  - 直至图中所有的顶点都并入T
  - 得到的T就是最小生成树
  - T中必然有n-1条边

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/413704bf3253c2671855c3395ee5f1027e23761bf8da66bca7df35e4ef0ebc82.jpg)  
图6.15Prim算法构造最小生成树的过程  

#### 算法步骤
##### 前提条件
- G={V,E}是连通图
- 其最小生成树T=(U,ET)
- ET是最小生成树中边的集合

##### 具体步骤
- 初始化
  - 向空树T=(U,ET)中添加图G=(V,E)的任意一个顶点u0
  - 使U={u0}
  - ET=∅
- 循环（重复下列操作直至U=V)
  - 从图G中选择满足{(u,v)|u∈U,v∈V-U}且具有最小权值的边(u,v)
  - 加入树T
  - 置U=U∪{v}, ET=ET∪{(u,v)}

#### 代码实现

void Prim（G,T）
T=∅  //初始化空树
U={w} //添加任意一个顶点w
while((V-U)!=∅) //若树中不含全部顶点
    设(u,v)是使u∈U与v∈(V-U)，且权值最小的边；
    T=T∪{(u,v)} //边归入树
    U=U∪{v} //顶点归入树


#### 算法复杂度
- 时间复杂度为O(|V|²)
- 不依赖于|E|
- 适用于求解边稠密的图的最小生成树
- 其他改进
  - 采用其他方法能改进Prim算法的时间复杂度
  - 但增加了实现的复杂性
</ul>

### Kruskal算法  
<ul>

#### 基本概念
- 与Prim算法不同的特点
  - Prim从顶点开始扩展最小生成树
  - Kruskal按权值递增次序选择合适的边来构造

> pro：Kruskal算法构造最小生成树的实例（2015、2018、2020）  

#### 构造过程
- 初始状态
  - 只有n个顶点而无边的非连通图T={V,{}}
  - 每个顶点自成一个连通分量
- 选边过程
  - 按边的权值由小到大顺序选取
  - 选择当前未被选取且权值最小的边
  - 判断条件
    - 若边的顶点落在T中不同连通分量上，则将此边加入T
    - 否则舍弃此边，选择下一条权值最小的边
- 终止条件
  - 直至T中所有顶点都在一个连通分量上

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfb9edf9b314446b65731e53e39a987ef76f3a653992a0d176bd51f77fe01337.jpg)  
图6.16Kruskal算法构造最小生成树的过程  

#### 算法步骤
##### 前提条件
- G=(V,E)是连通图
- 其最小生成树T=(U,ET)

##### 具体步骤
- 初始化
  - U=V,ET=∅
  - 每个顶点构成独立的树
  - T此时是仅含|V|个顶点的森林
- 循环（重复直至T是一棵树）
  - 按G的边的权值递增顺序从E-ET中选择边
  - 若加入T后不构成回路，则将其加入ET
  - 否则舍弃
  - 直到ET中含有n-1条边

#### 代码实现
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2b5891ebe5b470c06be5813e03e210a476a10eb80e5ae811e0df366ecf210561.jpg)  

#### 算法原理
- 边的连接特性
  - 若一条边连接两棵不同树中的顶点
  - 对这两棵树来说必定是连通的
  - 将边加入森林中完成两棵树的合并
  - 直到整个森林合并成一棵树

#### 算法复杂度
- 时间复杂度分析
  - 最坏情况需要对|E|条边各扫描一次
  - 采用堆存放边集合
    - 选择最小权值边需要O(log₂|E|)时间
  - 使用并查集判断顶点集合
    - 所需时间为O(α(|V|))
    - α(V)增长极其缓慢，可视为常数
- 总时间复杂度
  - O(|E|log₂|E|)
  - 不依赖于|V|
  - 适合于边稀疏而顶点较多的图
</ul>

</ul>    
    

</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
